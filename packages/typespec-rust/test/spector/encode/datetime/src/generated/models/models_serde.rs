// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use super::{
    DefaultDatetimeProperty, Rfc3339DatetimeProperty, Rfc7231DatetimeProperty,
    UnixTimestampArrayDatetimeProperty, UnixTimestampDatetimeProperty,
};
use azure_core::http::RequestContent;
use azure_core::{json::to_json, Result};

impl TryFrom<DefaultDatetimeProperty> for RequestContent<DefaultDatetimeProperty> {
    type Error = azure_core::Error;
    fn try_from(value: DefaultDatetimeProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<Rfc3339DatetimeProperty> for RequestContent<Rfc3339DatetimeProperty> {
    type Error = azure_core::Error;
    fn try_from(value: Rfc3339DatetimeProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<Rfc7231DatetimeProperty> for RequestContent<Rfc7231DatetimeProperty> {
    type Error = azure_core::Error;
    fn try_from(value: Rfc7231DatetimeProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<UnixTimestampArrayDatetimeProperty>
    for RequestContent<UnixTimestampArrayDatetimeProperty>
{
    type Error = azure_core::Error;
    fn try_from(value: UnixTimestampArrayDatetimeProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<UnixTimestampDatetimeProperty> for RequestContent<UnixTimestampDatetimeProperty> {
    type Error = azure_core::Error;
    fn try_from(value: UnixTimestampDatetimeProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

pub mod vec_offset_date_time_unix_time {
    #![allow(clippy::type_complexity)]
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<OffsetDateTime>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<i64>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<OffsetDateTime>>::new();
                for v in to_deserialize {
                    decoded0.push(
                        OffsetDateTime::from_unix_timestamp(v).map_err(serde::de::Error::custom)?,
                    );
                }
                Ok(decoded0)
            }
            None => Ok(<Vec<OffsetDateTime>>::default()),
        }
    }

    pub fn serialize<S>(to_serialize: &[OffsetDateTime], serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let encoded0 = to_serialize.iter().map(|v| v.unix_timestamp()).collect();
        <Vec<i64>>::serialize(&encoded0, serializer)
    }
}
