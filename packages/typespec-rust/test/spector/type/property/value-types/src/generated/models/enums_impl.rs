// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use crate::models::{
    ExtendedEnum, FixedInnerEnum, InnerEnum, UnionFloatLiteralPropertyProperty,
    UnionIntLiteralPropertyProperty, UnionStringLiteralPropertyProperty,
};
use azure_core::error::{Error, ErrorKind};
use std::{
    convert::{AsRef, From, Infallible},
    fmt::{Display, Formatter},
    str::FromStr,
};

impl<'a> From<&'a ExtendedEnum> for &'a str {
    fn from(e: &'a ExtendedEnum) -> Self {
        match e {
            ExtendedEnum::EnumValue2 => "value2",
            ExtendedEnum::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for ExtendedEnum {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "value2" => ExtendedEnum::EnumValue2,
            _ => ExtendedEnum::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for ExtendedEnum {
    fn as_ref(&self) -> &str {
        match self {
            ExtendedEnum::EnumValue2 => "value2",
            ExtendedEnum::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for ExtendedEnum {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            ExtendedEnum::EnumValue2 => f.write_str("value2"),
            ExtendedEnum::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl FromStr for FixedInnerEnum {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "ValueOne" => FixedInnerEnum::ValueOne,
            "ValueTwo" => FixedInnerEnum::ValueTwo,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of FixedInnerEnum found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for FixedInnerEnum {
    fn as_ref(&self) -> &str {
        match self {
            FixedInnerEnum::ValueOne => "ValueOne",
            FixedInnerEnum::ValueTwo => "ValueTwo",
        }
    }
}

impl Display for FixedInnerEnum {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            FixedInnerEnum::ValueOne => Display::fmt("ValueOne", f),
            FixedInnerEnum::ValueTwo => Display::fmt("ValueTwo", f),
        }
    }
}

impl<'a> From<&'a InnerEnum> for &'a str {
    fn from(e: &'a InnerEnum) -> Self {
        match e {
            InnerEnum::ValueOne => "ValueOne",
            InnerEnum::ValueTwo => "ValueTwo",
            InnerEnum::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for InnerEnum {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "ValueOne" => InnerEnum::ValueOne,
            "ValueTwo" => InnerEnum::ValueTwo,
            _ => InnerEnum::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for InnerEnum {
    fn as_ref(&self) -> &str {
        match self {
            InnerEnum::ValueOne => "ValueOne",
            InnerEnum::ValueTwo => "ValueTwo",
            InnerEnum::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for InnerEnum {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            InnerEnum::ValueOne => f.write_str("ValueOne"),
            InnerEnum::ValueTwo => f.write_str("ValueTwo"),
            InnerEnum::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl FromStr for UnionFloatLiteralPropertyProperty {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "43.125" => UnionFloatLiteralPropertyProperty::INVLD_IDENTIFIER_43_125,
            "46.875" => UnionFloatLiteralPropertyProperty::INVLD_IDENTIFIER_46_875,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of UnionFloatLiteralPropertyProperty found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for UnionFloatLiteralPropertyProperty {
    fn as_ref(&self) -> &str {
        match self {
            UnionFloatLiteralPropertyProperty::INVLD_IDENTIFIER_43_125 => "43.125",
            UnionFloatLiteralPropertyProperty::INVLD_IDENTIFIER_46_875 => "46.875",
        }
    }
}

impl Display for UnionFloatLiteralPropertyProperty {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            UnionFloatLiteralPropertyProperty::INVLD_IDENTIFIER_43_125 => Display::fmt("43.125", f),
            UnionFloatLiteralPropertyProperty::INVLD_IDENTIFIER_46_875 => Display::fmt("46.875", f),
        }
    }
}

impl FromStr for UnionIntLiteralPropertyProperty {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "42" => UnionIntLiteralPropertyProperty::INVLD_IDENTIFIER_42,
            "43" => UnionIntLiteralPropertyProperty::INVLD_IDENTIFIER_43,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of UnionIntLiteralPropertyProperty found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for UnionIntLiteralPropertyProperty {
    fn as_ref(&self) -> &str {
        match self {
            UnionIntLiteralPropertyProperty::INVLD_IDENTIFIER_42 => "42",
            UnionIntLiteralPropertyProperty::INVLD_IDENTIFIER_43 => "43",
        }
    }
}

impl Display for UnionIntLiteralPropertyProperty {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            UnionIntLiteralPropertyProperty::INVLD_IDENTIFIER_42 => Display::fmt("42", f),
            UnionIntLiteralPropertyProperty::INVLD_IDENTIFIER_43 => Display::fmt("43", f),
        }
    }
}

impl FromStr for UnionStringLiteralPropertyProperty {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "hello" => UnionStringLiteralPropertyProperty::Hello,
            "world" => UnionStringLiteralPropertyProperty::World,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of UnionStringLiteralPropertyProperty found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for UnionStringLiteralPropertyProperty {
    fn as_ref(&self) -> &str {
        match self {
            UnionStringLiteralPropertyProperty::Hello => "hello",
            UnionStringLiteralPropertyProperty::World => "world",
        }
    }
}

impl Display for UnionStringLiteralPropertyProperty {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            UnionStringLiteralPropertyProperty::Hello => Display::fmt("hello", f),
            UnionStringLiteralPropertyProperty::World => Display::fmt("world", f),
        }
    }
}
