// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use super::{
    BooleanLiteralProperty, BooleanProperty, BytesProperty, CollectionsIntProperty,
    CollectionsModelProperty, CollectionsStringProperty, DatetimeProperty, Decimal128Property,
    DecimalProperty, DictionaryStringProperty, DurationProperty, EnumProperty,
    ExtensibleEnumProperty, FloatLiteralProperty, FloatProperty, IntLiteralProperty, IntProperty,
    ModelProperty, NeverProperty, StringLiteralProperty, StringProperty, UnionEnumValueProperty,
    UnionFloatLiteralProperty, UnionIntLiteralProperty, UnionStringLiteralProperty,
    UnknownArrayProperty, UnknownDictProperty, UnknownIntProperty, UnknownStringProperty,
};
use azure_core::{http::RequestContent, json::to_json, Result};
use serde::Serializer;

impl TryFrom<BooleanLiteralProperty> for RequestContent<BooleanLiteralProperty> {
    type Error = azure_core::Error;
    fn try_from(value: BooleanLiteralProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<BooleanProperty> for RequestContent<BooleanProperty> {
    type Error = azure_core::Error;
    fn try_from(value: BooleanProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<BytesProperty> for RequestContent<BytesProperty> {
    type Error = azure_core::Error;
    fn try_from(value: BytesProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<CollectionsIntProperty> for RequestContent<CollectionsIntProperty> {
    type Error = azure_core::Error;
    fn try_from(value: CollectionsIntProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<CollectionsModelProperty> for RequestContent<CollectionsModelProperty> {
    type Error = azure_core::Error;
    fn try_from(value: CollectionsModelProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<CollectionsStringProperty> for RequestContent<CollectionsStringProperty> {
    type Error = azure_core::Error;
    fn try_from(value: CollectionsStringProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<DatetimeProperty> for RequestContent<DatetimeProperty> {
    type Error = azure_core::Error;
    fn try_from(value: DatetimeProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<Decimal128Property> for RequestContent<Decimal128Property> {
    type Error = azure_core::Error;
    fn try_from(value: Decimal128Property) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<DecimalProperty> for RequestContent<DecimalProperty> {
    type Error = azure_core::Error;
    fn try_from(value: DecimalProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<DictionaryStringProperty> for RequestContent<DictionaryStringProperty> {
    type Error = azure_core::Error;
    fn try_from(value: DictionaryStringProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<DurationProperty> for RequestContent<DurationProperty> {
    type Error = azure_core::Error;
    fn try_from(value: DurationProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<EnumProperty> for RequestContent<EnumProperty> {
    type Error = azure_core::Error;
    fn try_from(value: EnumProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<ExtensibleEnumProperty> for RequestContent<ExtensibleEnumProperty> {
    type Error = azure_core::Error;
    fn try_from(value: ExtensibleEnumProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<FloatLiteralProperty> for RequestContent<FloatLiteralProperty> {
    type Error = azure_core::Error;
    fn try_from(value: FloatLiteralProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<FloatProperty> for RequestContent<FloatProperty> {
    type Error = azure_core::Error;
    fn try_from(value: FloatProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<IntLiteralProperty> for RequestContent<IntLiteralProperty> {
    type Error = azure_core::Error;
    fn try_from(value: IntLiteralProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<IntProperty> for RequestContent<IntProperty> {
    type Error = azure_core::Error;
    fn try_from(value: IntProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<ModelProperty> for RequestContent<ModelProperty> {
    type Error = azure_core::Error;
    fn try_from(value: ModelProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<NeverProperty> for RequestContent<NeverProperty> {
    type Error = azure_core::Error;
    fn try_from(value: NeverProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<StringLiteralProperty> for RequestContent<StringLiteralProperty> {
    type Error = azure_core::Error;
    fn try_from(value: StringLiteralProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<StringProperty> for RequestContent<StringProperty> {
    type Error = azure_core::Error;
    fn try_from(value: StringProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<UnionEnumValueProperty> for RequestContent<UnionEnumValueProperty> {
    type Error = azure_core::Error;
    fn try_from(value: UnionEnumValueProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<UnionFloatLiteralProperty> for RequestContent<UnionFloatLiteralProperty> {
    type Error = azure_core::Error;
    fn try_from(value: UnionFloatLiteralProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<UnionIntLiteralProperty> for RequestContent<UnionIntLiteralProperty> {
    type Error = azure_core::Error;
    fn try_from(value: UnionIntLiteralProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<UnionStringLiteralProperty> for RequestContent<UnionStringLiteralProperty> {
    type Error = azure_core::Error;
    fn try_from(value: UnionStringLiteralProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<UnknownArrayProperty> for RequestContent<UnknownArrayProperty> {
    type Error = azure_core::Error;
    fn try_from(value: UnknownArrayProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<UnknownDictProperty> for RequestContent<UnknownDictProperty> {
    type Error = azure_core::Error;
    fn try_from(value: UnknownDictProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<UnknownIntProperty> for RequestContent<UnknownIntProperty> {
    type Error = azure_core::Error;
    fn try_from(value: UnknownIntProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

impl TryFrom<UnknownStringProperty> for RequestContent<UnknownStringProperty> {
    type Error = azure_core::Error;
    fn try_from(value: UnknownStringProperty) -> Result<Self> {
        RequestContent::try_from(to_json(&value)?)
    }
}

pub(crate) fn serialize_bool_literal_true<S>(
    _ignored: &Option<bool>,
    serializer: S,
) -> std::result::Result<S::Ok, S::Error>
where
    S: Serializer,
{
    serializer.serialize_bool(true)
}

pub(crate) fn serialize_f32_literal_43point125<S>(
    _ignored: &Option<f32>,
    serializer: S,
) -> std::result::Result<S::Ok, S::Error>
where
    S: Serializer,
{
    serializer.serialize_f32(43.125)
}

pub(crate) fn serialize_i32_literal_42<S>(
    _ignored: &Option<i32>,
    serializer: S,
) -> std::result::Result<S::Ok, S::Error>
where
    S: Serializer,
{
    serializer.serialize_i32(42)
}

pub(crate) fn serialize_string_literal_hello<S>(
    _ignored: &Option<String>,
    serializer: S,
) -> std::result::Result<S::Ok, S::Error>
where
    S: Serializer,
{
    serializer.serialize_str("hello")
}
