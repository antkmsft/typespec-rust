// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use crate::models::{
    And, As, Assert, Async, Await, Break, Class, Constructor, Continue, Def, Del, Elif, Else,
    Except, Exec, Finally, For, From, Global, If, Import, In, Is, Lambda, Not, Or, Pass, Raise,
    Return, Try, While, With, Yield,
};
use azure_core::{
    ClientMethodOptions, Context, Method, Pipeline, Request, RequestContent, Response, Result, Url,
};
use typespec_client_core::fmt::SafeDebug;

/// Verify model names
pub struct SpecialWordsModelsClient {
    pub(crate) endpoint: Url,
    pub(crate) pipeline: Pipeline,
}

impl SpecialWordsModelsClient {
    /// Returns the Url associated with this client.
    pub fn endpoint(&self) -> &Url {
        &self.endpoint
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_and(
        &self,
        body: RequestContent<And>,
        options: Option<SpecialWordsModelsClientWithAndOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/and")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_as(
        &self,
        body: RequestContent<As>,
        options: Option<SpecialWordsModelsClientWithAsOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/as")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_assert(
        &self,
        body: RequestContent<Assert>,
        options: Option<SpecialWordsModelsClientWithAssertOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/assert")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_async(
        &self,
        body: RequestContent<Async>,
        options: Option<SpecialWordsModelsClientWithAsyncOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/async")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_await(
        &self,
        body: RequestContent<Await>,
        options: Option<SpecialWordsModelsClientWithAwaitOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/await")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_break(
        &self,
        body: RequestContent<Break>,
        options: Option<SpecialWordsModelsClientWithBreakOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/break")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_class(
        &self,
        body: RequestContent<Class>,
        options: Option<SpecialWordsModelsClientWithClassOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/class")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_constructor(
        &self,
        body: RequestContent<Constructor>,
        options: Option<SpecialWordsModelsClientWithConstructorOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/constructor")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_continue(
        &self,
        body: RequestContent<Continue>,
        options: Option<SpecialWordsModelsClientWithContinueOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/continue")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_def(
        &self,
        body: RequestContent<Def>,
        options: Option<SpecialWordsModelsClientWithDefOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/def")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_del(
        &self,
        body: RequestContent<Del>,
        options: Option<SpecialWordsModelsClientWithDelOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/del")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_elif(
        &self,
        body: RequestContent<Elif>,
        options: Option<SpecialWordsModelsClientWithElifOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/elif")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_else(
        &self,
        body: RequestContent<Else>,
        options: Option<SpecialWordsModelsClientWithElseOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/else")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_except(
        &self,
        body: RequestContent<Except>,
        options: Option<SpecialWordsModelsClientWithExceptOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/except")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_exec(
        &self,
        body: RequestContent<Exec>,
        options: Option<SpecialWordsModelsClientWithExecOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/exec")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_finally(
        &self,
        body: RequestContent<Finally>,
        options: Option<SpecialWordsModelsClientWithFinallyOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/finally")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_for(
        &self,
        body: RequestContent<For>,
        options: Option<SpecialWordsModelsClientWithForOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/for")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_from(
        &self,
        body: RequestContent<From>,
        options: Option<SpecialWordsModelsClientWithFromOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/from")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_global(
        &self,
        body: RequestContent<Global>,
        options: Option<SpecialWordsModelsClientWithGlobalOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/global")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_if(
        &self,
        body: RequestContent<If>,
        options: Option<SpecialWordsModelsClientWithIfOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/if")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_import(
        &self,
        body: RequestContent<Import>,
        options: Option<SpecialWordsModelsClientWithImportOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/import")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_in(
        &self,
        body: RequestContent<In>,
        options: Option<SpecialWordsModelsClientWithInOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/in")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_is(
        &self,
        body: RequestContent<Is>,
        options: Option<SpecialWordsModelsClientWithIsOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/is")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_lambda(
        &self,
        body: RequestContent<Lambda>,
        options: Option<SpecialWordsModelsClientWithLambdaOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/lambda")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_not(
        &self,
        body: RequestContent<Not>,
        options: Option<SpecialWordsModelsClientWithNotOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/not")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_or(
        &self,
        body: RequestContent<Or>,
        options: Option<SpecialWordsModelsClientWithOrOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/or")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_pass(
        &self,
        body: RequestContent<Pass>,
        options: Option<SpecialWordsModelsClientWithPassOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/pass")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_raise(
        &self,
        body: RequestContent<Raise>,
        options: Option<SpecialWordsModelsClientWithRaiseOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/raise")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_return(
        &self,
        body: RequestContent<Return>,
        options: Option<SpecialWordsModelsClientWithReturnOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/return")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_try(
        &self,
        body: RequestContent<Try>,
        options: Option<SpecialWordsModelsClientWithTryOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/try")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_while(
        &self,
        body: RequestContent<While>,
        options: Option<SpecialWordsModelsClientWithWhileOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/while")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_with(
        &self,
        body: RequestContent<With>,
        options: Option<SpecialWordsModelsClientWithOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/with")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn with_yield(
        &self,
        body: RequestContent<Yield>,
        options: Option<SpecialWordsModelsClientWithYieldOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/yield")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }
}

/// Options to be passed to [`SpecialWordsModelsClient::with_and()`](crate::clients::SpecialWordsModelsClient::with_and())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithAndOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_as()`](crate::clients::SpecialWordsModelsClient::with_as())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithAsOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_assert()`](crate::clients::SpecialWordsModelsClient::with_assert())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithAssertOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_async()`](crate::clients::SpecialWordsModelsClient::with_async())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithAsyncOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_await()`](crate::clients::SpecialWordsModelsClient::with_await())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithAwaitOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_break()`](crate::clients::SpecialWordsModelsClient::with_break())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithBreakOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_class()`](crate::clients::SpecialWordsModelsClient::with_class())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithClassOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_constructor()`](crate::clients::SpecialWordsModelsClient::with_constructor())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithConstructorOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_continue()`](crate::clients::SpecialWordsModelsClient::with_continue())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithContinueOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_def()`](crate::clients::SpecialWordsModelsClient::with_def())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithDefOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_del()`](crate::clients::SpecialWordsModelsClient::with_del())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithDelOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_elif()`](crate::clients::SpecialWordsModelsClient::with_elif())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithElifOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_else()`](crate::clients::SpecialWordsModelsClient::with_else())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithElseOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_except()`](crate::clients::SpecialWordsModelsClient::with_except())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithExceptOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_exec()`](crate::clients::SpecialWordsModelsClient::with_exec())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithExecOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_finally()`](crate::clients::SpecialWordsModelsClient::with_finally())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithFinallyOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_for()`](crate::clients::SpecialWordsModelsClient::with_for())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithForOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_from()`](crate::clients::SpecialWordsModelsClient::with_from())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithFromOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_global()`](crate::clients::SpecialWordsModelsClient::with_global())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithGlobalOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_if()`](crate::clients::SpecialWordsModelsClient::with_if())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithIfOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_import()`](crate::clients::SpecialWordsModelsClient::with_import())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithImportOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_in()`](crate::clients::SpecialWordsModelsClient::with_in())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithInOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_is()`](crate::clients::SpecialWordsModelsClient::with_is())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithIsOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_lambda()`](crate::clients::SpecialWordsModelsClient::with_lambda())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithLambdaOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_not()`](crate::clients::SpecialWordsModelsClient::with_not())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithNotOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_or()`](crate::clients::SpecialWordsModelsClient::with_or())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithOrOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_pass()`](crate::clients::SpecialWordsModelsClient::with_pass())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithPassOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_raise()`](crate::clients::SpecialWordsModelsClient::with_raise())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithRaiseOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_return()`](crate::clients::SpecialWordsModelsClient::with_return())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithReturnOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_try()`](crate::clients::SpecialWordsModelsClient::with_try())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithTryOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_while()`](crate::clients::SpecialWordsModelsClient::with_while())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithWhileOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_with()`](crate::clients::SpecialWordsModelsClient::with_with())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}

/// Options to be passed to [`SpecialWordsModelsClient::with_yield()`](crate::clients::SpecialWordsModelsClient::with_yield())
#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithYieldOptions<'a> {
    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,
}
