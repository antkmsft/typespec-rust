// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use crate::models::{
    And, As, Assert, Async, Await, Break, Class, Constructor, Continue, Def, Del, Elif, Else,
    Except, Exec, Finally, For, From, Global, If, Import, In, Is, Lambda, Not, Or, Pass, Raise,
    Return, Try, While, With, Yield,
};
use azure_core::{
    ClientMethodOptions, Context, Method, Pipeline, Request, RequestContent, Response, Result, Url,
};
use typespec_client_core::fmt::SafeDebug;

pub struct SpecialWordsModelsClient {
    pub(crate) endpoint: Url,
    pub(crate) pipeline: Pipeline,
}

impl SpecialWordsModelsClient {
    /// Returns the Url associated with this client.
    pub fn endpoint(&self) -> &Url {
        &self.endpoint
    }

    pub async fn with_and(
        &self,
        body: RequestContent<And>,
        options: Option<SpecialWordsModelsClientWithAndOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/and")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_as(
        &self,
        body: RequestContent<As>,
        options: Option<SpecialWordsModelsClientWithAsOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/as")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_assert(
        &self,
        body: RequestContent<Assert>,
        options: Option<SpecialWordsModelsClientWithAssertOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/assert")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_async(
        &self,
        body: RequestContent<Async>,
        options: Option<SpecialWordsModelsClientWithAsyncOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/async")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_await(
        &self,
        body: RequestContent<Await>,
        options: Option<SpecialWordsModelsClientWithAwaitOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/await")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_break(
        &self,
        body: RequestContent<Break>,
        options: Option<SpecialWordsModelsClientWithBreakOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/break")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_class(
        &self,
        body: RequestContent<Class>,
        options: Option<SpecialWordsModelsClientWithClassOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/class")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_constructor(
        &self,
        body: RequestContent<Constructor>,
        options: Option<SpecialWordsModelsClientWithConstructorOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/constructor")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_continue(
        &self,
        body: RequestContent<Continue>,
        options: Option<SpecialWordsModelsClientWithContinueOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/continue")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_def(
        &self,
        body: RequestContent<Def>,
        options: Option<SpecialWordsModelsClientWithDefOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/def")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_del(
        &self,
        body: RequestContent<Del>,
        options: Option<SpecialWordsModelsClientWithDelOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/del")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_elif(
        &self,
        body: RequestContent<Elif>,
        options: Option<SpecialWordsModelsClientWithElifOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/elif")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_else(
        &self,
        body: RequestContent<Else>,
        options: Option<SpecialWordsModelsClientWithElseOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/else")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_except(
        &self,
        body: RequestContent<Except>,
        options: Option<SpecialWordsModelsClientWithExceptOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/except")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_exec(
        &self,
        body: RequestContent<Exec>,
        options: Option<SpecialWordsModelsClientWithExecOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/exec")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_finally(
        &self,
        body: RequestContent<Finally>,
        options: Option<SpecialWordsModelsClientWithFinallyOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/finally")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_for(
        &self,
        body: RequestContent<For>,
        options: Option<SpecialWordsModelsClientWithForOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/for")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_from(
        &self,
        body: RequestContent<From>,
        options: Option<SpecialWordsModelsClientWithFromOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/from")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_global(
        &self,
        body: RequestContent<Global>,
        options: Option<SpecialWordsModelsClientWithGlobalOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/global")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_if(
        &self,
        body: RequestContent<If>,
        options: Option<SpecialWordsModelsClientWithIfOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/if")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_import(
        &self,
        body: RequestContent<Import>,
        options: Option<SpecialWordsModelsClientWithImportOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/import")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_in(
        &self,
        body: RequestContent<In>,
        options: Option<SpecialWordsModelsClientWithInOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/in")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_is(
        &self,
        body: RequestContent<Is>,
        options: Option<SpecialWordsModelsClientWithIsOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/is")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_lambda(
        &self,
        body: RequestContent<Lambda>,
        options: Option<SpecialWordsModelsClientWithLambdaOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/lambda")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_not(
        &self,
        body: RequestContent<Not>,
        options: Option<SpecialWordsModelsClientWithNotOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/not")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_or(
        &self,
        body: RequestContent<Or>,
        options: Option<SpecialWordsModelsClientWithOrOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/or")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_pass(
        &self,
        body: RequestContent<Pass>,
        options: Option<SpecialWordsModelsClientWithPassOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/pass")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_raise(
        &self,
        body: RequestContent<Raise>,
        options: Option<SpecialWordsModelsClientWithRaiseOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/raise")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_return(
        &self,
        body: RequestContent<Return>,
        options: Option<SpecialWordsModelsClientWithReturnOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/return")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_try(
        &self,
        body: RequestContent<Try>,
        options: Option<SpecialWordsModelsClientWithTryOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/try")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_while(
        &self,
        body: RequestContent<While>,
        options: Option<SpecialWordsModelsClientWithWhileOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/while")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_with(
        &self,
        body: RequestContent<With>,
        options: Option<SpecialWordsModelsClientWithOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/with")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_yield(
        &self,
        body: RequestContent<Yield>,
        options: Option<SpecialWordsModelsClientWithYieldOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/models/yield")?;
        let mut request = Request::new(url, Method::Post);
        request.insert_header("content-type", "application/json");
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithAndOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithAsOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithAssertOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithAsyncOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithAwaitOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithBreakOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithClassOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithConstructorOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithContinueOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithDefOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithDelOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithElifOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithElseOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithExceptOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithExecOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithFinallyOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithForOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithFromOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithGlobalOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithIfOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithImportOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithInOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithIsOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithLambdaOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithNotOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithOrOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithPassOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithRaiseOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithReturnOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithTryOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithWhileOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Default, SafeDebug)]
pub struct SpecialWordsModelsClientWithYieldOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}
