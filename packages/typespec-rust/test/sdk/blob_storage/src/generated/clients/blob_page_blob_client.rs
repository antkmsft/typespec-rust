// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use crate::models::{PageList, PremiumPageBlobAccessTier, SequenceNumberActionType};
use azure_core::{
    AsClientMethodOptions, ClientMethodOptions, Method, Pipeline, Request, RequestContent,
    Response, Result, Url,
};
use time::OffsetDateTime;

pub struct BlobPageBlobClient {
    pub(in crate::generated::clients) endpoint: Url,
    pub(in crate::generated::clients) pipeline: Pipeline,
}

impl BlobPageBlobClient {
    /// The Clear Pages operation clears a range of pages from a page blob
    pub async fn clear_pages(
        &self,
        container_name: String,
        blob: String,
        content_length: i64,
        version: String,
        options: Option<BlobPageBlobClientClearPagesOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}?comp=page&clear");
        path = path.replace("{blob}", &blob);
        path = path.replace("{containerName}", &container_name);
        url.set_path(&path);
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-length", content_length.to_string());
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", if_modified_since.to_string());
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        if let Some(if_sequence_number_equal_to) = options.if_sequence_number_equal_to {
            request.insert_header(
                "x-ms-if-sequence-number-eq",
                if_sequence_number_equal_to.to_string(),
            );
        }
        if let Some(if_sequence_number_less_than_or_equal_to) =
            options.if_sequence_number_less_than_or_equal_to
        {
            request.insert_header(
                "x-ms-if-sequence-number-le",
                if_sequence_number_less_than_or_equal_to.to_string(),
            );
        }
        if let Some(if_sequence_number_less_than) = options.if_sequence_number_less_than {
            request.insert_header(
                "x-ms-if-sequence-number-lt",
                if_sequence_number_less_than.to_string(),
            );
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(range) = options.range {
            request.insert_header("x-ms-range", range);
        }
        request.insert_header("x-ms-version", version);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// The Copy Incremental operation copies a snapshot of the source page blob to a destination page blob. The snapshot is copied
    /// such that only the differential changes between the previously copied snapshot are transferred to the destination. The
    /// copied snapshots are complete copies of the original snapshot and can be read or copied from as usual. This API is supported
    /// since REST version 2016-05-31.
    pub async fn copy_incremental(
        &self,
        container_name: String,
        blob: String,
        copy_source: String,
        version: String,
        options: Option<BlobPageBlobClientCopyIncrementalOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}?comp=incrementalcopy");
        path = path.replace("{blob}", &blob);
        path = path.replace("{containerName}", &container_name);
        url.set_path(&path);
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", if_modified_since.to_string());
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        request.insert_header("x-ms-copy-source", copy_source);
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        request.insert_header("x-ms-version", version);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// The Create operation creates a new page blob.
    pub async fn create(
        &self,
        container_name: String,
        blob: String,
        content_length: i64,
        blob_content_length: i64,
        version: String,
        options: Option<BlobPageBlobClientCreateOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}?PageBlob");
        path = path.replace("{blob}", &blob);
        path = path.replace("{containerName}", &container_name);
        url.set_path(&path);
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-length", content_length.to_string());
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", if_modified_since.to_string());
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        if let Some(access_tier) = options.access_tier {
            request.insert_header("x-ms-access-tier", access_tier.to_string());
        }
        if let Some(blob_cache_control) = options.blob_cache_control {
            request.insert_header("x-ms-blob-cache-control", blob_cache_control);
        }
        if let Some(blob_content_disposition) = options.blob_content_disposition {
            request.insert_header("x-ms-blob-content-disposition", blob_content_disposition);
        }
        if let Some(blob_content_encoding) = options.blob_content_encoding {
            request.insert_header("x-ms-blob-content-encoding", blob_content_encoding);
        }
        if let Some(blob_content_language) = options.blob_content_language {
            request.insert_header("x-ms-blob-content-language", blob_content_language);
        }
        request.insert_header("x-ms-blob-content-length", blob_content_length.to_string());
        if let Some(blob_content_md5) = options.blob_content_md5 {
            request.insert_header("x-ms-blob-content-md5", blob_content_md5);
        }
        if let Some(blob_content_type) = options.blob_content_type {
            request.insert_header("x-ms-blob-content-type", blob_content_type);
        }
        if let Some(blob_sequence_number) = options.blob_sequence_number {
            request.insert_header(
                "x-ms-blob-sequence-number",
                blob_sequence_number.to_string(),
            );
        }
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header("x-ms-encryption-algorithm", encryption_algorithm);
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(immutability_policy_expiry) = options.immutability_policy_expiry {
            request.insert_header(
                "x-ms-immutability-policy-until-date",
                immutability_policy_expiry,
            );
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(legal_hold) = options.legal_hold {
            request.insert_header("x-ms-legal-hold", legal_hold.to_string());
        }
        if let Some(blob_tags_string) = options.blob_tags_string {
            request.insert_header("x-ms-tags", blob_tags_string);
        }
        request.insert_header("x-ms-version", version);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// The Get Page Ranges operation returns the list of valid page ranges for a page blob or snapshot of a page blob.
    pub async fn get_page_ranges(
        &self,
        container_name: String,
        blob: String,
        version: String,
        options: Option<BlobPageBlobClientGetPageRangesOptions<'_>>,
    ) -> Result<Response<PageList>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}?comp=pagelist");
        path = path.replace("{blob}", &blob);
        path = path.replace("{containerName}", &container_name);
        url.set_path(&path);
        if let Some(marker) = options.marker {
            url.query_pairs_mut().append_pair("marker", &marker);
        }
        if let Some(maxresults) = options.maxresults {
            url.query_pairs_mut()
                .append_pair("maxresults", &maxresults.to_string());
        }
        if let Some(snapshot) = options.snapshot {
            url.query_pairs_mut().append_pair("snapshot", &snapshot);
        }
        let mut request = Request::new(url, Method::Get);
        request.insert_header("accept", "application/json");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", if_modified_since.to_string());
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(range) = options.range {
            request.insert_header("x-ms-range", range);
        }
        request.insert_header("x-ms-version", version);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// The Get Page Ranges Diff operation returns the list of valid page ranges for a page blob or snapshot of a page blob.
    pub async fn get_page_ranges_diff(
        &self,
        container_name: String,
        blob: String,
        prevsnapshot: String,
        prev_snapshot_url: String,
        version: String,
        options: Option<BlobPageBlobClientGetPageRangesDiffOptions<'_>>,
    ) -> Result<Response<PageList>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}?comp=pagelist&diff");
        path = path.replace("{blob}", &blob);
        path = path.replace("{containerName}", &container_name);
        url.set_path(&path);
        if let Some(marker) = options.marker {
            url.query_pairs_mut().append_pair("marker", &marker);
        }
        if let Some(maxresults) = options.maxresults {
            url.query_pairs_mut()
                .append_pair("maxresults", &maxresults.to_string());
        }
        url.query_pairs_mut()
            .append_pair("prevsnapshot", &prevsnapshot);
        if let Some(snapshot) = options.snapshot {
            url.query_pairs_mut().append_pair("snapshot", &snapshot);
        }
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Get);
        request.insert_header("accept", "application/json");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", if_modified_since.to_string());
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        request.insert_header("x-ms-previous-snapshot-url", prev_snapshot_url);
        if let Some(range) = options.range {
            request.insert_header("x-ms-range", range);
        }
        request.insert_header("x-ms-version", version);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// The Resize operation increases the size of the page blob to the specified size.
    pub async fn resize(
        &self,
        container_name: String,
        blob: String,
        blob_content_length: i64,
        version: String,
        options: Option<BlobPageBlobClientResizeOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}?comp=properties&Resize");
        path = path.replace("{blob}", &blob);
        path = path.replace("{containerName}", &container_name);
        url.set_path(&path);
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", if_modified_since.to_string());
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        request.insert_header("x-ms-blob-content-length", blob_content_length.to_string());
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header("x-ms-encryption-algorithm", encryption_algorithm);
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        request.insert_header("x-ms-version", version);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// The Update Sequence Number operation sets the blob's sequence number. The operation will fail if the specified sequence
    /// number is less than the current sequence number of the blob.
    pub async fn update_sequence_number(
        &self,
        container_name: String,
        blob: String,
        sequence_number_action: SequenceNumberActionType,
        blob_sequence_number: i64,
        version: String,
        options: Option<BlobPageBlobClientUpdateSequenceNumberOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}?comp=properties&UpdateSequenceNumber");
        path = path.replace("{blob}", &blob);
        path = path.replace("{containerName}", &container_name);
        url.set_path(&path);
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", if_modified_since.to_string());
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        request.insert_header(
            "x-ms-blob-sequence-number",
            blob_sequence_number.to_string(),
        );
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        request.insert_header(
            "x-ms-sequence-number-action",
            sequence_number_action.to_string(),
        );
        request.insert_header("x-ms-version", version);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// The Upload Pages operation writes a range of pages to a page blob
    pub async fn upload_pages(
        &self,
        body: RequestContent<Vec<u8>>,
        container_name: String,
        blob: String,
        content_length: i64,
        version: String,
        options: Option<BlobPageBlobClientUploadPagesOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}?comp=page&update");
        path = path.replace("{blob}", &blob);
        path = path.replace("{containerName}", &container_name);
        url.set_path(&path);
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-length", content_length.to_string());
        if let Some(transactional_content_md5) = options.transactional_content_md5 {
            request.insert_header("content-md5", transactional_content_md5);
        }
        request.insert_header("content-type", "application/json");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", if_modified_since.to_string());
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        if let Some(transactional_content_crc64) = options.transactional_content_crc64 {
            request.insert_header("x-ms-content-crc64", transactional_content_crc64);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header("x-ms-encryption-algorithm", encryption_algorithm);
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(if_sequence_number_equal_to) = options.if_sequence_number_equal_to {
            request.insert_header(
                "x-ms-if-sequence-number-eq",
                if_sequence_number_equal_to.to_string(),
            );
        }
        if let Some(if_sequence_number_less_than_or_equal_to) =
            options.if_sequence_number_less_than_or_equal_to
        {
            request.insert_header(
                "x-ms-if-sequence-number-le",
                if_sequence_number_less_than_or_equal_to.to_string(),
            );
        }
        if let Some(if_sequence_number_less_than) = options.if_sequence_number_less_than {
            request.insert_header(
                "x-ms-if-sequence-number-lt",
                if_sequence_number_less_than.to_string(),
            );
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(range) = options.range {
            request.insert_header("x-ms-range", range);
        }
        request.insert_header("x-ms-version", version);
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// The Upload Pages operation writes a range of pages to a page blob where the contents are read from a URL.
    pub async fn upload_pages_from_url(
        &self,
        container_name: String,
        blob: String,
        content_length: i64,
        source_url: String,
        source_range: String,
        range: String,
        version: String,
        options: Option<BlobPageBlobClientUploadPagesFromUrlOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}?comp=page&update&fromUrl");
        path = path.replace("{blob}", &blob);
        path = path.replace("{containerName}", &container_name);
        url.set_path(&path);
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-length", content_length.to_string());
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", if_modified_since.to_string());
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        if let Some(copy_source_authorization) = options.copy_source_authorization {
            request.insert_header("x-ms-copy-source-authorization", copy_source_authorization);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header("x-ms-encryption-algorithm", encryption_algorithm);
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(if_sequence_number_equal_to) = options.if_sequence_number_equal_to {
            request.insert_header(
                "x-ms-if-sequence-number-eq",
                if_sequence_number_equal_to.to_string(),
            );
        }
        if let Some(if_sequence_number_less_than_or_equal_to) =
            options.if_sequence_number_less_than_or_equal_to
        {
            request.insert_header(
                "x-ms-if-sequence-number-le",
                if_sequence_number_less_than_or_equal_to.to_string(),
            );
        }
        if let Some(if_sequence_number_less_than) = options.if_sequence_number_less_than {
            request.insert_header(
                "x-ms-if-sequence-number-lt",
                if_sequence_number_less_than.to_string(),
            );
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        request.insert_header("x-ms-range", range);
        if let Some(source_content_crc64) = options.source_content_crc64 {
            request.insert_header("x-ms-source-content-crc64", source_content_crc64);
        }
        if let Some(source_content_md5) = options.source_content_md5 {
            request.insert_header("x-ms-source-content-md5", source_content_md5);
        }
        if let Some(source_if_match) = options.source_if_match {
            request.insert_header("x-ms-source-if-match", source_if_match);
        }
        if let Some(source_if_modified_since) = options.source_if_modified_since {
            request.insert_header(
                "x-ms-source-if-modified-since",
                source_if_modified_since.to_string(),
            );
        }
        if let Some(source_if_none_match) = options.source_if_none_match {
            request.insert_header("x-ms-source-if-none-match", source_if_none_match);
        }
        if let Some(source_if_unmodified_since) = options.source_if_unmodified_since {
            request.insert_header(
                "x-ms-source-if-unmodified-since",
                source_if_unmodified_since.to_string(),
            );
        }
        request.insert_header("x-ms-source-range", source_range);
        request.insert_header("x-ms-source-url", source_url);
        request.insert_header("x-ms-version", version);
        self.pipeline.send(&mut ctx, &mut request).await
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobPageBlobClientClearPagesOptions<'a> {
    pub if_match: Option<String>,
    pub if_modified_since: Option<OffsetDateTime>,
    pub if_none_match: Option<String>,
    pub if_sequence_number_equal_to: Option<i64>,
    pub if_sequence_number_less_than: Option<i64>,
    pub if_sequence_number_less_than_or_equal_to: Option<i64>,
    pub if_tags: Option<String>,
    pub if_unmodified_since: Option<OffsetDateTime>,
    pub lease_id: Option<String>,
    pub method_options: ClientMethodOptions<'a>,
    pub range: Option<String>,
    pub request_id: Option<String>,
    pub timeout: Option<i32>,
}

#[derive(Clone, Debug, Default)]
pub struct BlobPageBlobClientCopyIncrementalOptions<'a> {
    pub if_match: Option<String>,
    pub if_modified_since: Option<OffsetDateTime>,
    pub if_none_match: Option<String>,
    pub if_tags: Option<String>,
    pub if_unmodified_since: Option<OffsetDateTime>,
    pub lease_id: Option<String>,
    pub method_options: ClientMethodOptions<'a>,
    pub request_id: Option<String>,
    pub timeout: Option<i32>,
}

#[derive(Clone, Debug, Default)]
pub struct BlobPageBlobClientCreateOptions<'a> {
    pub access_tier: Option<PremiumPageBlobAccessTier>,
    pub blob_cache_control: Option<String>,
    pub blob_content_disposition: Option<String>,
    pub blob_content_encoding: Option<String>,
    pub blob_content_language: Option<String>,
    pub blob_content_md5: Option<String>,
    pub blob_content_type: Option<String>,
    pub blob_sequence_number: Option<i64>,
    pub blob_tags_string: Option<String>,
    pub encryption_algorithm: Option<String>,
    pub encryption_key: Option<String>,
    pub encryption_key_sha256: Option<String>,
    pub encryption_scope: Option<String>,
    pub if_match: Option<String>,
    pub if_modified_since: Option<OffsetDateTime>,
    pub if_none_match: Option<String>,
    pub if_tags: Option<String>,
    pub if_unmodified_since: Option<OffsetDateTime>,
    pub immutability_policy_expiry: Option<String>,
    pub lease_id: Option<String>,
    pub legal_hold: Option<bool>,
    pub method_options: ClientMethodOptions<'a>,
    pub request_id: Option<String>,
    pub timeout: Option<i32>,
}

#[derive(Clone, Debug, Default)]
pub struct BlobPageBlobClientGetPageRangesOptions<'a> {
    pub if_match: Option<String>,
    pub if_modified_since: Option<OffsetDateTime>,
    pub if_none_match: Option<String>,
    pub if_tags: Option<String>,
    pub if_unmodified_since: Option<OffsetDateTime>,
    pub lease_id: Option<String>,
    pub marker: Option<String>,
    pub maxresults: Option<i32>,
    pub method_options: ClientMethodOptions<'a>,
    pub range: Option<String>,
    pub request_id: Option<String>,
    pub snapshot: Option<String>,
}

#[derive(Clone, Debug, Default)]
pub struct BlobPageBlobClientGetPageRangesDiffOptions<'a> {
    pub if_match: Option<String>,
    pub if_modified_since: Option<OffsetDateTime>,
    pub if_none_match: Option<String>,
    pub if_tags: Option<String>,
    pub if_unmodified_since: Option<OffsetDateTime>,
    pub lease_id: Option<String>,
    pub marker: Option<String>,
    pub maxresults: Option<i32>,
    pub method_options: ClientMethodOptions<'a>,
    pub range: Option<String>,
    pub request_id: Option<String>,
    pub snapshot: Option<String>,
    pub timeout: Option<i32>,
}

#[derive(Clone, Debug, Default)]
pub struct BlobPageBlobClientResizeOptions<'a> {
    pub encryption_algorithm: Option<String>,
    pub encryption_key: Option<String>,
    pub encryption_key_sha256: Option<String>,
    pub encryption_scope: Option<String>,
    pub if_match: Option<String>,
    pub if_modified_since: Option<OffsetDateTime>,
    pub if_none_match: Option<String>,
    pub if_tags: Option<String>,
    pub if_unmodified_since: Option<OffsetDateTime>,
    pub lease_id: Option<String>,
    pub method_options: ClientMethodOptions<'a>,
    pub request_id: Option<String>,
    pub timeout: Option<i32>,
}

#[derive(Clone, Debug, Default)]
pub struct BlobPageBlobClientUpdateSequenceNumberOptions<'a> {
    pub if_match: Option<String>,
    pub if_modified_since: Option<OffsetDateTime>,
    pub if_none_match: Option<String>,
    pub if_tags: Option<String>,
    pub if_unmodified_since: Option<OffsetDateTime>,
    pub lease_id: Option<String>,
    pub method_options: ClientMethodOptions<'a>,
    pub request_id: Option<String>,
    pub timeout: Option<i32>,
}

#[derive(Clone, Debug, Default)]
pub struct BlobPageBlobClientUploadPagesOptions<'a> {
    pub encryption_algorithm: Option<String>,
    pub encryption_key: Option<String>,
    pub encryption_key_sha256: Option<String>,
    pub encryption_scope: Option<String>,
    pub if_match: Option<String>,
    pub if_modified_since: Option<OffsetDateTime>,
    pub if_none_match: Option<String>,
    pub if_sequence_number_equal_to: Option<i64>,
    pub if_sequence_number_less_than: Option<i64>,
    pub if_sequence_number_less_than_or_equal_to: Option<i64>,
    pub if_tags: Option<String>,
    pub if_unmodified_since: Option<OffsetDateTime>,
    pub lease_id: Option<String>,
    pub method_options: ClientMethodOptions<'a>,
    pub range: Option<String>,
    pub request_id: Option<String>,
    pub timeout: Option<i32>,
    pub transactional_content_crc64: Option<String>,
    pub transactional_content_md5: Option<String>,
}

#[derive(Clone, Debug, Default)]
pub struct BlobPageBlobClientUploadPagesFromUrlOptions<'a> {
    pub copy_source_authorization: Option<String>,
    pub encryption_algorithm: Option<String>,
    pub encryption_key: Option<String>,
    pub encryption_key_sha256: Option<String>,
    pub encryption_scope: Option<String>,
    pub if_match: Option<String>,
    pub if_modified_since: Option<OffsetDateTime>,
    pub if_none_match: Option<String>,
    pub if_sequence_number_equal_to: Option<i64>,
    pub if_sequence_number_less_than: Option<i64>,
    pub if_sequence_number_less_than_or_equal_to: Option<i64>,
    pub if_tags: Option<String>,
    pub if_unmodified_since: Option<OffsetDateTime>,
    pub lease_id: Option<String>,
    pub method_options: ClientMethodOptions<'a>,
    pub request_id: Option<String>,
    pub source_content_crc64: Option<String>,
    pub source_content_md5: Option<String>,
    pub source_if_match: Option<String>,
    pub source_if_modified_since: Option<OffsetDateTime>,
    pub source_if_none_match: Option<String>,
    pub source_if_unmodified_since: Option<OffsetDateTime>,
    pub timeout: Option<i32>,
}
