// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use crate::models::{BlobImmutabilityPolicyMode, EncryptionAlgorithmType};
use azure_core::{
    base64, date, Bytes, ClientMethodOptions, Context, Method, Pipeline, Request, RequestContent,
    Response, Result, Url,
};
use std::collections::HashMap;
use time::OffsetDateTime;
use typespec_client_core::fmt::SafeDebug;

pub struct BlobAppendBlobClient {
    pub(crate) blob: String,
    pub(crate) container_name: String,
    pub(crate) endpoint: Url,
    pub(crate) pipeline: Pipeline,
    pub(crate) version: String,
}

impl BlobAppendBlobClient {
    /// Returns the Url associated with this client.
    pub fn endpoint(&self) -> &Url {
        &self.endpoint
    }

    /// The Append Block operation commits a new block of data to the end of an append blob.
    ///
    /// # Arguments
    ///
    /// * `body` - The body of the request.
    /// * `content_length` - The length of the request.
    /// * `options` - Optional parameters for the request.
    pub async fn append_block(
        &self,
        body: RequestContent<Bytes>,
        content_length: i64,
        options: Option<BlobAppendBlobClientAppendBlockOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("{containerName}/{blob}");
        path = path.replace("{blob}", &self.blob);
        path = path.replace("{containerName}", &self.container_name);
        url = url.join(&path)?;
        url.query_pairs_mut().append_pair("comp", "appendblock");
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-length", content_length.to_string());
        if let Some(transactional_content_md5) = options.transactional_content_md5 {
            request.insert_header("content-md5", transactional_content_md5);
        }
        request.insert_header("content-type", "application/xml");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", date::to_rfc7231(&if_modified_since));
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header(
                "if-unmodified-since",
                date::to_rfc7231(&if_unmodified_since),
            );
        }
        if let Some(append_position) = options.append_position {
            request.insert_header("x-ms-blob-condition-appendpos", append_position.to_string());
        }
        if let Some(max_size) = options.max_size {
            request.insert_header("x-ms-blob-condition-maxsize", max_size.to_string());
        }
        if let Some(client_request_id) = options.client_request_id {
            request.insert_header("x-ms-client-request-id", client_request_id);
        }
        if let Some(transactional_content_crc64) = options.transactional_content_crc64 {
            request.insert_header("x-ms-content-crc64", transactional_content_crc64);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header(
                "x-ms-encryption-algorithm",
                encryption_algorithm.to_string(),
            );
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(structured_body_type) = options.structured_body_type {
            request.insert_header("x-ms-structured-body", structured_body_type);
        }
        if let Some(structured_content_length) = options.structured_content_length {
            request.insert_header(
                "x-ms-structured-content-length",
                structured_content_length.to_string(),
            );
        }
        request.insert_header("x-ms-version", &self.version);
        request.set_body(body);
        self.pipeline.send(&ctx, &mut request).await
    }

    /// The Append Block From URL operation creates a new block to be committed as part of an append blob where the contents are
    /// read from a URL.
    ///
    /// # Arguments
    ///
    /// * `source_url` - Specify a URL to the copy source.
    /// * `content_length` - The length of the request.
    /// * `options` - Optional parameters for the request.
    pub async fn append_block_from_url(
        &self,
        source_url: &str,
        content_length: i64,
        options: Option<BlobAppendBlobClientAppendBlockFromUrlOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("{containerName}/{blob}");
        path = path.replace("{blob}", &self.blob);
        path = path.replace("{containerName}", &self.container_name);
        url = url.join(&path)?;
        url.query_pairs_mut()
            .append_pair("comp", "appendblock")
            .append_key_only("fromUrl");
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-length", content_length.to_string());
        if let Some(transactional_content_md5) = options.transactional_content_md5 {
            request.insert_header("content-md5", transactional_content_md5);
        }
        request.insert_header("content-type", "application/xml");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", date::to_rfc7231(&if_modified_since));
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header(
                "if-unmodified-since",
                date::to_rfc7231(&if_unmodified_since),
            );
        }
        if let Some(append_position) = options.append_position {
            request.insert_header("x-ms-blob-condition-appendpos", append_position.to_string());
        }
        if let Some(max_size) = options.max_size {
            request.insert_header("x-ms-blob-condition-maxsize", max_size.to_string());
        }
        if let Some(client_request_id) = options.client_request_id {
            request.insert_header("x-ms-client-request-id", client_request_id);
        }
        request.insert_header("x-ms-copy-source", source_url.to_owned());
        if let Some(copy_source_authorization) = options.copy_source_authorization {
            request.insert_header("x-ms-copy-source-authorization", copy_source_authorization);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header(
                "x-ms-encryption-algorithm",
                encryption_algorithm.to_string(),
            );
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(source_content_crc64) = options.source_content_crc64 {
            request.insert_header(
                "x-ms-source-content-crc64",
                base64::encode(source_content_crc64),
            );
        }
        if let Some(source_content_md5) = options.source_content_md5 {
            request.insert_header("x-ms-source-content-md5", source_content_md5);
        }
        if let Some(source_if_match) = options.source_if_match {
            request.insert_header("x-ms-source-if-match", source_if_match);
        }
        if let Some(source_if_modified_since) = options.source_if_modified_since {
            request.insert_header("x-ms-source-if-modified-since", source_if_modified_since);
        }
        if let Some(source_if_none_match) = options.source_if_none_match {
            request.insert_header("x-ms-source-if-none-match", source_if_none_match);
        }
        if let Some(source_if_unmodified_since) = options.source_if_unmodified_since {
            request.insert_header(
                "x-ms-source-if-unmodified-since",
                source_if_unmodified_since,
            );
        }
        if let Some(source_range) = options.source_range {
            request.insert_header("x-ms-source-range", source_range);
        }
        request.insert_header("x-ms-version", &self.version);
        self.pipeline.send(&ctx, &mut request).await
    }

    /// The Create operation creates a new append blob.
    ///
    /// # Arguments
    ///
    /// * `content_length` - The length of the request.
    /// * `options` - Optional parameters for the request.
    pub async fn create(
        &self,
        content_length: i64,
        options: Option<BlobAppendBlobClientCreateOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("{containerName}/{blob}");
        path = path.replace("{blob}", &self.blob);
        path = path.replace("{containerName}", &self.container_name);
        url = url.join(&path)?;
        url.query_pairs_mut().append_key_only("AppendBlob");
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-length", content_length.to_string());
        request.insert_header("content-type", "application/octet-stream");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", date::to_rfc7231(&if_modified_since));
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header(
                "if-unmodified-since",
                date::to_rfc7231(&if_unmodified_since),
            );
        }
        if let Some(blob_cache_control) = options.blob_cache_control {
            request.insert_header("x-ms-blob-cache-control", blob_cache_control);
        }
        if let Some(blob_content_disposition) = options.blob_content_disposition {
            request.insert_header("x-ms-blob-content-disposition", blob_content_disposition);
        }
        if let Some(blob_content_encoding) = options.blob_content_encoding {
            request.insert_header("x-ms-blob-content-encoding", blob_content_encoding);
        }
        if let Some(blob_content_language) = options.blob_content_language {
            request.insert_header("x-ms-blob-content-language", blob_content_language);
        }
        if let Some(blob_content_md5) = options.blob_content_md5 {
            request.insert_header("x-ms-blob-content-md5", base64::encode(blob_content_md5));
        }
        if let Some(blob_content_type) = options.blob_content_type {
            request.insert_header("x-ms-blob-content-type", blob_content_type);
        }
        request.insert_header("x-ms-blob-type", "AppendBlob");
        if let Some(client_request_id) = options.client_request_id {
            request.insert_header("x-ms-client-request-id", client_request_id);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header(
                "x-ms-encryption-algorithm",
                encryption_algorithm.to_string(),
            );
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(immutability_policy_mode) = options.immutability_policy_mode {
            request.insert_header(
                "x-ms-immutability-policy-mode",
                immutability_policy_mode.to_string(),
            );
        }
        if let Some(immutability_policy_expiry) = options.immutability_policy_expiry {
            request.insert_header(
                "x-ms-immutability-policy-until-date",
                immutability_policy_expiry,
            );
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(legal_hold) = options.legal_hold {
            request.insert_header("x-ms-legal-hold", legal_hold.to_string());
        }
        if let Some(metadata) = options.metadata {
            for (k, v) in &metadata {
                request.insert_header(format!("x-ms-meta-{}", k), v);
            }
        }
        if let Some(blob_tags_string) = options.blob_tags_string {
            request.insert_header("x-ms-tags", blob_tags_string);
        }
        request.insert_header("x-ms-version", &self.version);
        self.pipeline.send(&ctx, &mut request).await
    }

    /// The Seal operation seals the Append Blob to make it read-only. Seal is supported only on version 2019-12-12 version or
    /// later.
    ///
    /// # Arguments
    ///
    /// * `options` - Optional parameters for the request.
    pub async fn seal(
        &self,
        options: Option<BlobAppendBlobClientSealOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        let mut path = String::from("{containerName}/{blob}");
        path = path.replace("{blob}", &self.blob);
        path = path.replace("{containerName}", &self.container_name);
        url = url.join(&path)?;
        url.query_pairs_mut().append_pair("comp", "seal");
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/xml");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", date::to_rfc7231(&if_modified_since));
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header(
                "if-unmodified-since",
                date::to_rfc7231(&if_unmodified_since),
            );
        }
        if let Some(append_position) = options.append_position {
            request.insert_header("x-ms-blob-condition-appendpos", append_position.to_string());
        }
        if let Some(client_request_id) = options.client_request_id {
            request.insert_header("x-ms-client-request-id", client_request_id);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        request.insert_header("x-ms-version", &self.version);
        self.pipeline.send(&ctx, &mut request).await
    }
}

/// Options to be passed to [`BlobAppendBlobClient::append_block()`](crate::clients::BlobAppendBlobClient::append_block())
#[derive(Clone, Default, SafeDebug)]
pub struct BlobAppendBlobClientAppendBlockOptions<'a> {
    /// Optional conditional header, used only for the Append Block operation. A number indicating the byte offset to compare.
    /// Append Block will succeed only if the append position is equal to this number. If it is not, the request will fail with
    /// the AppendPositionConditionNotMet error (HTTP status code 412 - Precondition Failed).
    pub append_position: Option<i64>,

    /// An opaque, globally-unique, client-generated string identifier for the request.
    pub client_request_id: Option<String>,

    /// Optional. Version 2019-07-07 and later. Specifies the algorithm to use for encryption. If not specified, the default is
    /// AES256.
    pub encryption_algorithm: Option<EncryptionAlgorithmType>,

    /// Optional. Version 2019-07-07 and later. Specifies the encryption key to use to encrypt the data provided in the request.
    /// If not specified, the request will be encrypted with the root account key.
    pub encryption_key: Option<String>,

    /// Optional. Version 2019-07-07 and later. Specifies the SHA256 hash of the encryption key used to encrypt the data provided
    /// in the request. This header is only used for encryption with a customer-provided key. If the request is authenticated
    /// with a client token, this header should be specified using the SHA256 hash of the encryption key.
    pub encryption_key_sha256: Option<String>,

    /// Optional. Version 2019-07-07 and later. Specifies the encryption scope to use to encrypt the data provided in the request.
    /// If not specified, the request will be encrypted with the root account key.
    pub encryption_scope: Option<String>,

    /// The request should only proceed if an entity matches this string.
    pub if_match: Option<String>,

    /// The request should only proceed if the entity was modified after this time.
    pub if_modified_since: Option<OffsetDateTime>,

    /// The request should only proceed if no entity matches this string.
    pub if_none_match: Option<String>,

    /// Specify a SQL where clause on blob tags to operate only on blobs with a matching value.
    pub if_tags: Option<String>,

    /// The request should only proceed if the entity was not modified after this time.
    pub if_unmodified_since: Option<OffsetDateTime>,

    /// If specified, the operation only succeeds if the resource's lease is active and matches this ID.
    pub lease_id: Option<String>,

    /// Optional conditional header. The max length in bytes permitted for the append blob. If the Append Block operation would
    /// cause the blob to exceed that limit or if the blob size is already greater than the value specified in this header, the
    /// request will fail with MaxBlobSizeConditionNotMet error (HTTP status code 412 - Precondition Failed).
    pub max_size: Option<i64>,

    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,

    /// Required if the request body is a structured message. Specifies the message schema version and properties.
    pub structured_body_type: Option<String>,

    /// Required if the request body is a structured message. Specifies the length of the blob/file content inside the message
    /// body. Will always be smaller than Content-Length.
    pub structured_content_length: Option<i64>,

    /// The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
    /// Timeouts for Blob Service Operations.</a>
    pub timeout: Option<i32>,

    /// Specify the transactional crc64 for the body, to be validated by the service.
    pub transactional_content_crc64: Option<String>,

    /// Optional. An MD5 hash of the blob content. Note that this hash is not validated, as the hashes for the individual blocks
    /// were validated when each was uploaded.
    pub transactional_content_md5: Option<String>,
}

/// Options to be passed to [`BlobAppendBlobClient::append_block_from_url()`](crate::clients::BlobAppendBlobClient::append_block_from_url())
#[derive(Clone, Default, SafeDebug)]
pub struct BlobAppendBlobClientAppendBlockFromUrlOptions<'a> {
    /// Optional conditional header, used only for the Append Block operation. A number indicating the byte offset to compare.
    /// Append Block will succeed only if the append position is equal to this number. If it is not, the request will fail with
    /// the AppendPositionConditionNotMet error (HTTP status code 412 - Precondition Failed).
    pub append_position: Option<i64>,

    /// An opaque, globally-unique, client-generated string identifier for the request.
    pub client_request_id: Option<String>,

    /// Only Bearer type is supported. Credentials should be a valid OAuth access token to copy source.
    pub copy_source_authorization: Option<String>,

    /// Optional. Version 2019-07-07 and later. Specifies the algorithm to use for encryption. If not specified, the default is
    /// AES256.
    pub encryption_algorithm: Option<EncryptionAlgorithmType>,

    /// Optional. Version 2019-07-07 and later. Specifies the encryption key to use to encrypt the data provided in the request.
    /// If not specified, the request will be encrypted with the root account key.
    pub encryption_key: Option<String>,

    /// Optional. Version 2019-07-07 and later. Specifies the SHA256 hash of the encryption key used to encrypt the data provided
    /// in the request. This header is only used for encryption with a customer-provided key. If the request is authenticated
    /// with a client token, this header should be specified using the SHA256 hash of the encryption key.
    pub encryption_key_sha256: Option<String>,

    /// Optional. Version 2019-07-07 and later. Specifies the encryption scope to use to encrypt the data provided in the request.
    /// If not specified, the request will be encrypted with the root account key.
    pub encryption_scope: Option<String>,

    /// The request should only proceed if an entity matches this string.
    pub if_match: Option<String>,

    /// The request should only proceed if the entity was modified after this time.
    pub if_modified_since: Option<OffsetDateTime>,

    /// The request should only proceed if no entity matches this string.
    pub if_none_match: Option<String>,

    /// Specify a SQL where clause on blob tags to operate only on blobs with a matching value.
    pub if_tags: Option<String>,

    /// The request should only proceed if the entity was not modified after this time.
    pub if_unmodified_since: Option<OffsetDateTime>,

    /// If specified, the operation only succeeds if the resource's lease is active and matches this ID.
    pub lease_id: Option<String>,

    /// Optional conditional header. The max length in bytes permitted for the append blob. If the Append Block operation would
    /// cause the blob to exceed that limit or if the blob size is already greater than the value specified in this header, the
    /// request will fail with MaxBlobSizeConditionNotMet error (HTTP status code 412 - Precondition Failed).
    pub max_size: Option<i64>,

    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,

    /// Specify the crc64 calculated for the range of bytes that must be read from the copy source.
    pub source_content_crc64: Option<Vec<u8>>,

    /// Specify the md5 calculated for the range of bytes that must be read from the copy source.
    pub source_content_md5: Option<String>,

    /// Specify an ETag value to operate only on blobs with a matching value.
    pub source_if_match: Option<String>,

    /// Specify this header value to operate only on a blob if it has been modified since the specified date/time.
    pub source_if_modified_since: Option<String>,

    /// Specify this header value to operate only on a blob if it has been modified since the specified date/time.
    pub source_if_none_match: Option<String>,

    /// Specify this header value to operate only on a blob if it has not been modified since the specified date/time.
    pub source_if_unmodified_since: Option<String>,

    /// Bytes of source data in the specified range.
    pub source_range: Option<String>,

    /// The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
    /// Timeouts for Blob Service Operations.</a>
    pub timeout: Option<i32>,

    /// Optional. An MD5 hash of the blob content. Note that this hash is not validated, as the hashes for the individual blocks
    /// were validated when each was uploaded.
    pub transactional_content_md5: Option<String>,
}

/// Options to be passed to [`BlobAppendBlobClient::create()`](crate::clients::BlobAppendBlobClient::create())
#[derive(Clone, Default, SafeDebug)]
pub struct BlobAppendBlobClientCreateOptions<'a> {
    /// Optional. Sets the blob's cache control. If specified, this property is stored with the blob and returned with a read
    /// request.
    pub blob_cache_control: Option<String>,

    /// Optional. Sets the blob's content disposition. If specified, this property is stored with the blob and returned with a
    /// read request.
    pub blob_content_disposition: Option<String>,

    /// Optional. Sets the blob's content encoding. If specified, this property is stored with the blob and returned with a read
    /// request.
    pub blob_content_encoding: Option<String>,

    /// Optional. Set the blob's content language. If specified, this property is stored with the blob and returned with a read
    /// request.
    pub blob_content_language: Option<String>,

    /// Optional. An MD5 hash of the blob content. Note that this hash is not validated, as the hashes for the individual blocks
    /// were validated when each was uploaded.
    pub blob_content_md5: Option<Vec<u8>>,

    /// Optional. Sets the blob's content type. If specified, this property is stored with the blob and returned with a read request.
    pub blob_content_type: Option<String>,

    /// Optional. Used to set blob tags in various blob operations.
    pub blob_tags_string: Option<String>,

    /// An opaque, globally-unique, client-generated string identifier for the request.
    pub client_request_id: Option<String>,

    /// Optional. Version 2019-07-07 and later. Specifies the algorithm to use for encryption. If not specified, the default is
    /// AES256.
    pub encryption_algorithm: Option<EncryptionAlgorithmType>,

    /// Optional. Version 2019-07-07 and later. Specifies the encryption key to use to encrypt the data provided in the request.
    /// If not specified, the request will be encrypted with the root account key.
    pub encryption_key: Option<String>,

    /// Optional. Version 2019-07-07 and later. Specifies the SHA256 hash of the encryption key used to encrypt the data provided
    /// in the request. This header is only used for encryption with a customer-provided key. If the request is authenticated
    /// with a client token, this header should be specified using the SHA256 hash of the encryption key.
    pub encryption_key_sha256: Option<String>,

    /// Optional. Version 2019-07-07 and later. Specifies the encryption scope to use to encrypt the data provided in the request.
    /// If not specified, the request will be encrypted with the root account key.
    pub encryption_scope: Option<String>,

    /// The request should only proceed if an entity matches this string.
    pub if_match: Option<String>,

    /// The request should only proceed if the entity was modified after this time.
    pub if_modified_since: Option<OffsetDateTime>,

    /// The request should only proceed if no entity matches this string.
    pub if_none_match: Option<String>,

    /// Specify a SQL where clause on blob tags to operate only on blobs with a matching value.
    pub if_tags: Option<String>,

    /// The request should only proceed if the entity was not modified after this time.
    pub if_unmodified_since: Option<OffsetDateTime>,

    /// Specifies the date time when the blobs immutability policy is set to expire.
    pub immutability_policy_expiry: Option<String>,

    /// Specifies the immutability policy mode to set on the blob.
    pub immutability_policy_mode: Option<BlobImmutabilityPolicyMode>,

    /// If specified, the operation only succeeds if the resource's lease is active and matches this ID.
    pub lease_id: Option<String>,

    /// Specified if a legal hold should be set on the blob.
    pub legal_hold: Option<bool>,

    /// The metadata headers.
    pub metadata: Option<HashMap<String, String>>,

    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,

    /// The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
    /// Timeouts for Blob Service Operations.</a>
    pub timeout: Option<i32>,
}

/// Options to be passed to [`BlobAppendBlobClient::seal()`](crate::clients::BlobAppendBlobClient::seal())
#[derive(Clone, Default, SafeDebug)]
pub struct BlobAppendBlobClientSealOptions<'a> {
    /// Optional conditional header, used only for the Append Block operation. A number indicating the byte offset to compare.
    /// Append Block will succeed only if the append position is equal to this number. If it is not, the request will fail with
    /// the AppendPositionConditionNotMet error (HTTP status code 412 - Precondition Failed).
    pub append_position: Option<i64>,

    /// An opaque, globally-unique, client-generated string identifier for the request.
    pub client_request_id: Option<String>,

    /// The request should only proceed if an entity matches this string.
    pub if_match: Option<String>,

    /// The request should only proceed if the entity was modified after this time.
    pub if_modified_since: Option<OffsetDateTime>,

    /// The request should only proceed if no entity matches this string.
    pub if_none_match: Option<String>,

    /// The request should only proceed if the entity was not modified after this time.
    pub if_unmodified_since: Option<OffsetDateTime>,

    /// If specified, the operation only succeeds if the resource's lease is active and matches this ID.
    pub lease_id: Option<String>,

    /// Allows customization of the method call.
    pub method_options: ClientMethodOptions<'a>,

    /// The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
    /// Timeouts for Blob Service Operations.</a>
    pub timeout: Option<i32>,
}
