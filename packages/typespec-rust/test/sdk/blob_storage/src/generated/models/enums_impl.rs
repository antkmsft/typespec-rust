// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use crate::models::{
    AccessTier, AccountKind, ArchiveStatus, BlobDeleteType, BlobExpiryOptions,
    BlobImmutabilityPolicyMode, BlobType, BlockListType, CopyStatus, DeleteSnapshotsOptionType,
    EncryptionAlgorithmType, FilterBlobsIncludeItem, GeoReplicationStatusType, LeaseDuration,
    LeaseState, LeaseStatus, ListBlobsIncludeItem, ListContainersIncludeType,
    PremiumPageBlobAccessTier, PublicAccessType, QueryRequestType, QueryType, RehydratePriority,
    SequenceNumberActionType, SkuName,
};
use std::{
    convert::{AsRef, From, Infallible},
    fmt::{Display, Formatter},
    str::FromStr,
};

impl<'a> From<&'a AccessTier> for &'a str {
    fn from(e: &'a AccessTier) -> Self {
        match e {
            AccessTier::Archive => "Archive",
            AccessTier::Cold => "Cold",
            AccessTier::Cool => "Cool",
            AccessTier::Hot => "Hot",
            AccessTier::P10 => "P10",
            AccessTier::P15 => "P15",
            AccessTier::P20 => "P20",
            AccessTier::P30 => "P30",
            AccessTier::P4 => "P4",
            AccessTier::P40 => "P40",
            AccessTier::P50 => "P50",
            AccessTier::P6 => "P6",
            AccessTier::P60 => "P60",
            AccessTier::P70 => "P70",
            AccessTier::P80 => "P80",
            AccessTier::Premium => "Premium",
            AccessTier::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for AccessTier {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "Archive" => AccessTier::Archive,
            "Cold" => AccessTier::Cold,
            "Cool" => AccessTier::Cool,
            "Hot" => AccessTier::Hot,
            "P10" => AccessTier::P10,
            "P15" => AccessTier::P15,
            "P20" => AccessTier::P20,
            "P30" => AccessTier::P30,
            "P4" => AccessTier::P4,
            "P40" => AccessTier::P40,
            "P50" => AccessTier::P50,
            "P6" => AccessTier::P6,
            "P60" => AccessTier::P60,
            "P70" => AccessTier::P70,
            "P80" => AccessTier::P80,
            "Premium" => AccessTier::Premium,
            _ => AccessTier::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for AccessTier {
    fn as_ref(&self) -> &str {
        match self {
            AccessTier::Archive => "Archive",
            AccessTier::Cold => "Cold",
            AccessTier::Cool => "Cool",
            AccessTier::Hot => "Hot",
            AccessTier::P10 => "P10",
            AccessTier::P15 => "P15",
            AccessTier::P20 => "P20",
            AccessTier::P30 => "P30",
            AccessTier::P4 => "P4",
            AccessTier::P40 => "P40",
            AccessTier::P50 => "P50",
            AccessTier::P6 => "P6",
            AccessTier::P60 => "P60",
            AccessTier::P70 => "P70",
            AccessTier::P80 => "P80",
            AccessTier::Premium => "Premium",
            AccessTier::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for AccessTier {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            AccessTier::Archive => f.write_str("Archive"),
            AccessTier::Cold => f.write_str("Cold"),
            AccessTier::Cool => f.write_str("Cool"),
            AccessTier::Hot => f.write_str("Hot"),
            AccessTier::P10 => f.write_str("P10"),
            AccessTier::P15 => f.write_str("P15"),
            AccessTier::P20 => f.write_str("P20"),
            AccessTier::P30 => f.write_str("P30"),
            AccessTier::P4 => f.write_str("P4"),
            AccessTier::P40 => f.write_str("P40"),
            AccessTier::P50 => f.write_str("P50"),
            AccessTier::P6 => f.write_str("P6"),
            AccessTier::P60 => f.write_str("P60"),
            AccessTier::P70 => f.write_str("P70"),
            AccessTier::P80 => f.write_str("P80"),
            AccessTier::Premium => f.write_str("Premium"),
            AccessTier::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a AccountKind> for &'a str {
    fn from(e: &'a AccountKind) -> Self {
        match e {
            AccountKind::BlobStorage => "BlobStorage",
            AccountKind::BlockBlobStorage => "BlockBlobStorage",
            AccountKind::FileStorage => "FileStorage",
            AccountKind::Storage => "Storage",
            AccountKind::StorageV2 => "StorageV2",
            AccountKind::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for AccountKind {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "BlobStorage" => AccountKind::BlobStorage,
            "BlockBlobStorage" => AccountKind::BlockBlobStorage,
            "FileStorage" => AccountKind::FileStorage,
            "Storage" => AccountKind::Storage,
            "StorageV2" => AccountKind::StorageV2,
            _ => AccountKind::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for AccountKind {
    fn as_ref(&self) -> &str {
        match self {
            AccountKind::BlobStorage => "BlobStorage",
            AccountKind::BlockBlobStorage => "BlockBlobStorage",
            AccountKind::FileStorage => "FileStorage",
            AccountKind::Storage => "Storage",
            AccountKind::StorageV2 => "StorageV2",
            AccountKind::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for AccountKind {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            AccountKind::BlobStorage => f.write_str("BlobStorage"),
            AccountKind::BlockBlobStorage => f.write_str("BlockBlobStorage"),
            AccountKind::FileStorage => f.write_str("FileStorage"),
            AccountKind::Storage => f.write_str("Storage"),
            AccountKind::StorageV2 => f.write_str("StorageV2"),
            AccountKind::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a ArchiveStatus> for &'a str {
    fn from(e: &'a ArchiveStatus) -> Self {
        match e {
            ArchiveStatus::RehydratePendingToCold => "rehydrate-pending-to-cold",
            ArchiveStatus::RehydratePendingToCool => "rehydrate-pending-to-cool",
            ArchiveStatus::RehydratePendingToHot => "rehydrate-pending-to-hot",
            ArchiveStatus::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for ArchiveStatus {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "rehydrate-pending-to-cold" => ArchiveStatus::RehydratePendingToCold,
            "rehydrate-pending-to-cool" => ArchiveStatus::RehydratePendingToCool,
            "rehydrate-pending-to-hot" => ArchiveStatus::RehydratePendingToHot,
            _ => ArchiveStatus::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for ArchiveStatus {
    fn as_ref(&self) -> &str {
        match self {
            ArchiveStatus::RehydratePendingToCold => "rehydrate-pending-to-cold",
            ArchiveStatus::RehydratePendingToCool => "rehydrate-pending-to-cool",
            ArchiveStatus::RehydratePendingToHot => "rehydrate-pending-to-hot",
            ArchiveStatus::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for ArchiveStatus {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            ArchiveStatus::RehydratePendingToCold => f.write_str("rehydrate-pending-to-cold"),
            ArchiveStatus::RehydratePendingToCool => f.write_str("rehydrate-pending-to-cool"),
            ArchiveStatus::RehydratePendingToHot => f.write_str("rehydrate-pending-to-hot"),
            ArchiveStatus::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a BlobDeleteType> for &'a str {
    fn from(e: &'a BlobDeleteType) -> Self {
        match e {
            BlobDeleteType::Permanent => "Permanent",
            BlobDeleteType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for BlobDeleteType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "Permanent" => BlobDeleteType::Permanent,
            _ => BlobDeleteType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for BlobDeleteType {
    fn as_ref(&self) -> &str {
        match self {
            BlobDeleteType::Permanent => "Permanent",
            BlobDeleteType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for BlobDeleteType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            BlobDeleteType::Permanent => f.write_str("Permanent"),
            BlobDeleteType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a BlobExpiryOptions> for &'a str {
    fn from(e: &'a BlobExpiryOptions) -> Self {
        match e {
            BlobExpiryOptions::Absolute => "Absolute",
            BlobExpiryOptions::NeverExpire => "NeverExpire",
            BlobExpiryOptions::RelativeToCreation => "RelativeToCreation",
            BlobExpiryOptions::RelativeToNow => "RelativeToNow",
            BlobExpiryOptions::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for BlobExpiryOptions {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "Absolute" => BlobExpiryOptions::Absolute,
            "NeverExpire" => BlobExpiryOptions::NeverExpire,
            "RelativeToCreation" => BlobExpiryOptions::RelativeToCreation,
            "RelativeToNow" => BlobExpiryOptions::RelativeToNow,
            _ => BlobExpiryOptions::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for BlobExpiryOptions {
    fn as_ref(&self) -> &str {
        match self {
            BlobExpiryOptions::Absolute => "Absolute",
            BlobExpiryOptions::NeverExpire => "NeverExpire",
            BlobExpiryOptions::RelativeToCreation => "RelativeToCreation",
            BlobExpiryOptions::RelativeToNow => "RelativeToNow",
            BlobExpiryOptions::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for BlobExpiryOptions {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            BlobExpiryOptions::Absolute => f.write_str("Absolute"),
            BlobExpiryOptions::NeverExpire => f.write_str("NeverExpire"),
            BlobExpiryOptions::RelativeToCreation => f.write_str("RelativeToCreation"),
            BlobExpiryOptions::RelativeToNow => f.write_str("RelativeToNow"),
            BlobExpiryOptions::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a BlobImmutabilityPolicyMode> for &'a str {
    fn from(e: &'a BlobImmutabilityPolicyMode) -> Self {
        match e {
            BlobImmutabilityPolicyMode::Locked => "Locked",
            BlobImmutabilityPolicyMode::Mutable => "Mutable",
            BlobImmutabilityPolicyMode::Unlocked => "Unlocked",
            BlobImmutabilityPolicyMode::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for BlobImmutabilityPolicyMode {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "Locked" => BlobImmutabilityPolicyMode::Locked,
            "Mutable" => BlobImmutabilityPolicyMode::Mutable,
            "Unlocked" => BlobImmutabilityPolicyMode::Unlocked,
            _ => BlobImmutabilityPolicyMode::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for BlobImmutabilityPolicyMode {
    fn as_ref(&self) -> &str {
        match self {
            BlobImmutabilityPolicyMode::Locked => "Locked",
            BlobImmutabilityPolicyMode::Mutable => "Mutable",
            BlobImmutabilityPolicyMode::Unlocked => "Unlocked",
            BlobImmutabilityPolicyMode::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for BlobImmutabilityPolicyMode {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            BlobImmutabilityPolicyMode::Locked => f.write_str("Locked"),
            BlobImmutabilityPolicyMode::Mutable => f.write_str("Mutable"),
            BlobImmutabilityPolicyMode::Unlocked => f.write_str("Unlocked"),
            BlobImmutabilityPolicyMode::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a BlobType> for &'a str {
    fn from(e: &'a BlobType) -> Self {
        match e {
            BlobType::AppendBlob => "AppendBlob",
            BlobType::BlockBlob => "BlockBlob",
            BlobType::PageBlob => "PageBlob",
            BlobType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for BlobType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "AppendBlob" => BlobType::AppendBlob,
            "BlockBlob" => BlobType::BlockBlob,
            "PageBlob" => BlobType::PageBlob,
            _ => BlobType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for BlobType {
    fn as_ref(&self) -> &str {
        match self {
            BlobType::AppendBlob => "AppendBlob",
            BlobType::BlockBlob => "BlockBlob",
            BlobType::PageBlob => "PageBlob",
            BlobType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for BlobType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            BlobType::AppendBlob => f.write_str("AppendBlob"),
            BlobType::BlockBlob => f.write_str("BlockBlob"),
            BlobType::PageBlob => f.write_str("PageBlob"),
            BlobType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a BlockListType> for &'a str {
    fn from(e: &'a BlockListType) -> Self {
        match e {
            BlockListType::All => "all",
            BlockListType::Committed => "committed",
            BlockListType::Uncommitted => "uncommitted",
            BlockListType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for BlockListType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "all" => BlockListType::All,
            "committed" => BlockListType::Committed,
            "uncommitted" => BlockListType::Uncommitted,
            _ => BlockListType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for BlockListType {
    fn as_ref(&self) -> &str {
        match self {
            BlockListType::All => "all",
            BlockListType::Committed => "committed",
            BlockListType::Uncommitted => "uncommitted",
            BlockListType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for BlockListType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            BlockListType::All => f.write_str("all"),
            BlockListType::Committed => f.write_str("committed"),
            BlockListType::Uncommitted => f.write_str("uncommitted"),
            BlockListType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a CopyStatus> for &'a str {
    fn from(e: &'a CopyStatus) -> Self {
        match e {
            CopyStatus::Aborted => "aborted",
            CopyStatus::Failed => "failed",
            CopyStatus::Pending => "pending",
            CopyStatus::Success => "success",
            CopyStatus::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for CopyStatus {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "aborted" => CopyStatus::Aborted,
            "failed" => CopyStatus::Failed,
            "pending" => CopyStatus::Pending,
            "success" => CopyStatus::Success,
            _ => CopyStatus::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for CopyStatus {
    fn as_ref(&self) -> &str {
        match self {
            CopyStatus::Aborted => "aborted",
            CopyStatus::Failed => "failed",
            CopyStatus::Pending => "pending",
            CopyStatus::Success => "success",
            CopyStatus::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for CopyStatus {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            CopyStatus::Aborted => f.write_str("aborted"),
            CopyStatus::Failed => f.write_str("failed"),
            CopyStatus::Pending => f.write_str("pending"),
            CopyStatus::Success => f.write_str("success"),
            CopyStatus::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a DeleteSnapshotsOptionType> for &'a str {
    fn from(e: &'a DeleteSnapshotsOptionType) -> Self {
        match e {
            DeleteSnapshotsOptionType::Include => "include",
            DeleteSnapshotsOptionType::Only => "only",
            DeleteSnapshotsOptionType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for DeleteSnapshotsOptionType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "include" => DeleteSnapshotsOptionType::Include,
            "only" => DeleteSnapshotsOptionType::Only,
            _ => DeleteSnapshotsOptionType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for DeleteSnapshotsOptionType {
    fn as_ref(&self) -> &str {
        match self {
            DeleteSnapshotsOptionType::Include => "include",
            DeleteSnapshotsOptionType::Only => "only",
            DeleteSnapshotsOptionType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for DeleteSnapshotsOptionType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            DeleteSnapshotsOptionType::Include => f.write_str("include"),
            DeleteSnapshotsOptionType::Only => f.write_str("only"),
            DeleteSnapshotsOptionType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a EncryptionAlgorithmType> for &'a str {
    fn from(e: &'a EncryptionAlgorithmType) -> Self {
        match e {
            EncryptionAlgorithmType::Aes256 => "AES256",
            EncryptionAlgorithmType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for EncryptionAlgorithmType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "AES256" => EncryptionAlgorithmType::Aes256,
            _ => EncryptionAlgorithmType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for EncryptionAlgorithmType {
    fn as_ref(&self) -> &str {
        match self {
            EncryptionAlgorithmType::Aes256 => "AES256",
            EncryptionAlgorithmType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for EncryptionAlgorithmType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            EncryptionAlgorithmType::Aes256 => f.write_str("AES256"),
            EncryptionAlgorithmType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a FilterBlobsIncludeItem> for &'a str {
    fn from(e: &'a FilterBlobsIncludeItem) -> Self {
        match e {
            FilterBlobsIncludeItem::None => "none",
            FilterBlobsIncludeItem::Versions => "versions",
            FilterBlobsIncludeItem::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for FilterBlobsIncludeItem {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "none" => FilterBlobsIncludeItem::None,
            "versions" => FilterBlobsIncludeItem::Versions,
            _ => FilterBlobsIncludeItem::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for FilterBlobsIncludeItem {
    fn as_ref(&self) -> &str {
        match self {
            FilterBlobsIncludeItem::None => "none",
            FilterBlobsIncludeItem::Versions => "versions",
            FilterBlobsIncludeItem::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for FilterBlobsIncludeItem {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            FilterBlobsIncludeItem::None => f.write_str("none"),
            FilterBlobsIncludeItem::Versions => f.write_str("versions"),
            FilterBlobsIncludeItem::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a GeoReplicationStatusType> for &'a str {
    fn from(e: &'a GeoReplicationStatusType) -> Self {
        match e {
            GeoReplicationStatusType::Bootstrap => "bootstrap",
            GeoReplicationStatusType::Live => "live",
            GeoReplicationStatusType::Unavailable => "unavailable",
            GeoReplicationStatusType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for GeoReplicationStatusType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "bootstrap" => GeoReplicationStatusType::Bootstrap,
            "live" => GeoReplicationStatusType::Live,
            "unavailable" => GeoReplicationStatusType::Unavailable,
            _ => GeoReplicationStatusType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for GeoReplicationStatusType {
    fn as_ref(&self) -> &str {
        match self {
            GeoReplicationStatusType::Bootstrap => "bootstrap",
            GeoReplicationStatusType::Live => "live",
            GeoReplicationStatusType::Unavailable => "unavailable",
            GeoReplicationStatusType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for GeoReplicationStatusType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            GeoReplicationStatusType::Bootstrap => f.write_str("bootstrap"),
            GeoReplicationStatusType::Live => f.write_str("live"),
            GeoReplicationStatusType::Unavailable => f.write_str("unavailable"),
            GeoReplicationStatusType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a LeaseDuration> for &'a str {
    fn from(e: &'a LeaseDuration) -> Self {
        match e {
            LeaseDuration::Fixed => "fixed",
            LeaseDuration::Infinite => "infinite",
            LeaseDuration::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for LeaseDuration {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "fixed" => LeaseDuration::Fixed,
            "infinite" => LeaseDuration::Infinite,
            _ => LeaseDuration::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for LeaseDuration {
    fn as_ref(&self) -> &str {
        match self {
            LeaseDuration::Fixed => "fixed",
            LeaseDuration::Infinite => "infinite",
            LeaseDuration::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for LeaseDuration {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            LeaseDuration::Fixed => f.write_str("fixed"),
            LeaseDuration::Infinite => f.write_str("infinite"),
            LeaseDuration::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a LeaseState> for &'a str {
    fn from(e: &'a LeaseState) -> Self {
        match e {
            LeaseState::Available => "available",
            LeaseState::Breaking => "breaking",
            LeaseState::Broken => "broken",
            LeaseState::Expired => "expired",
            LeaseState::Leased => "leased",
            LeaseState::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for LeaseState {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "available" => LeaseState::Available,
            "breaking" => LeaseState::Breaking,
            "broken" => LeaseState::Broken,
            "expired" => LeaseState::Expired,
            "leased" => LeaseState::Leased,
            _ => LeaseState::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for LeaseState {
    fn as_ref(&self) -> &str {
        match self {
            LeaseState::Available => "available",
            LeaseState::Breaking => "breaking",
            LeaseState::Broken => "broken",
            LeaseState::Expired => "expired",
            LeaseState::Leased => "leased",
            LeaseState::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for LeaseState {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            LeaseState::Available => f.write_str("available"),
            LeaseState::Breaking => f.write_str("breaking"),
            LeaseState::Broken => f.write_str("broken"),
            LeaseState::Expired => f.write_str("expired"),
            LeaseState::Leased => f.write_str("leased"),
            LeaseState::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a LeaseStatus> for &'a str {
    fn from(e: &'a LeaseStatus) -> Self {
        match e {
            LeaseStatus::Locked => "locked",
            LeaseStatus::Unlocked => "unlocked",
            LeaseStatus::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for LeaseStatus {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "locked" => LeaseStatus::Locked,
            "unlocked" => LeaseStatus::Unlocked,
            _ => LeaseStatus::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for LeaseStatus {
    fn as_ref(&self) -> &str {
        match self {
            LeaseStatus::Locked => "locked",
            LeaseStatus::Unlocked => "unlocked",
            LeaseStatus::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for LeaseStatus {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            LeaseStatus::Locked => f.write_str("locked"),
            LeaseStatus::Unlocked => f.write_str("unlocked"),
            LeaseStatus::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a ListBlobsIncludeItem> for &'a str {
    fn from(e: &'a ListBlobsIncludeItem) -> Self {
        match e {
            ListBlobsIncludeItem::Copy => "copy",
            ListBlobsIncludeItem::Deleted => "deleted",
            ListBlobsIncludeItem::DeletedWithVersions => "deletedwithversions",
            ListBlobsIncludeItem::ImmutabilityPolicy => "immutabilitypolicy",
            ListBlobsIncludeItem::LegalHold => "legalhold",
            ListBlobsIncludeItem::Metadata => "metadata",
            ListBlobsIncludeItem::Snapshots => "snapshots",
            ListBlobsIncludeItem::Tags => "tags",
            ListBlobsIncludeItem::UncommittedBlobs => "uncommittedblobs",
            ListBlobsIncludeItem::Versions => "versions",
            ListBlobsIncludeItem::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for ListBlobsIncludeItem {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "copy" => ListBlobsIncludeItem::Copy,
            "deleted" => ListBlobsIncludeItem::Deleted,
            "deletedwithversions" => ListBlobsIncludeItem::DeletedWithVersions,
            "immutabilitypolicy" => ListBlobsIncludeItem::ImmutabilityPolicy,
            "legalhold" => ListBlobsIncludeItem::LegalHold,
            "metadata" => ListBlobsIncludeItem::Metadata,
            "snapshots" => ListBlobsIncludeItem::Snapshots,
            "tags" => ListBlobsIncludeItem::Tags,
            "uncommittedblobs" => ListBlobsIncludeItem::UncommittedBlobs,
            "versions" => ListBlobsIncludeItem::Versions,
            _ => ListBlobsIncludeItem::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for ListBlobsIncludeItem {
    fn as_ref(&self) -> &str {
        match self {
            ListBlobsIncludeItem::Copy => "copy",
            ListBlobsIncludeItem::Deleted => "deleted",
            ListBlobsIncludeItem::DeletedWithVersions => "deletedwithversions",
            ListBlobsIncludeItem::ImmutabilityPolicy => "immutabilitypolicy",
            ListBlobsIncludeItem::LegalHold => "legalhold",
            ListBlobsIncludeItem::Metadata => "metadata",
            ListBlobsIncludeItem::Snapshots => "snapshots",
            ListBlobsIncludeItem::Tags => "tags",
            ListBlobsIncludeItem::UncommittedBlobs => "uncommittedblobs",
            ListBlobsIncludeItem::Versions => "versions",
            ListBlobsIncludeItem::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for ListBlobsIncludeItem {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            ListBlobsIncludeItem::Copy => f.write_str("copy"),
            ListBlobsIncludeItem::Deleted => f.write_str("deleted"),
            ListBlobsIncludeItem::DeletedWithVersions => f.write_str("deletedwithversions"),
            ListBlobsIncludeItem::ImmutabilityPolicy => f.write_str("immutabilitypolicy"),
            ListBlobsIncludeItem::LegalHold => f.write_str("legalhold"),
            ListBlobsIncludeItem::Metadata => f.write_str("metadata"),
            ListBlobsIncludeItem::Snapshots => f.write_str("snapshots"),
            ListBlobsIncludeItem::Tags => f.write_str("tags"),
            ListBlobsIncludeItem::UncommittedBlobs => f.write_str("uncommittedblobs"),
            ListBlobsIncludeItem::Versions => f.write_str("versions"),
            ListBlobsIncludeItem::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a ListContainersIncludeType> for &'a str {
    fn from(e: &'a ListContainersIncludeType) -> Self {
        match e {
            ListContainersIncludeType::Deleted => "deleted",
            ListContainersIncludeType::Metadata => "metadata",
            ListContainersIncludeType::System => "system",
            ListContainersIncludeType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for ListContainersIncludeType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "deleted" => ListContainersIncludeType::Deleted,
            "metadata" => ListContainersIncludeType::Metadata,
            "system" => ListContainersIncludeType::System,
            _ => ListContainersIncludeType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for ListContainersIncludeType {
    fn as_ref(&self) -> &str {
        match self {
            ListContainersIncludeType::Deleted => "deleted",
            ListContainersIncludeType::Metadata => "metadata",
            ListContainersIncludeType::System => "system",
            ListContainersIncludeType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for ListContainersIncludeType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            ListContainersIncludeType::Deleted => f.write_str("deleted"),
            ListContainersIncludeType::Metadata => f.write_str("metadata"),
            ListContainersIncludeType::System => f.write_str("system"),
            ListContainersIncludeType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a PremiumPageBlobAccessTier> for &'a str {
    fn from(e: &'a PremiumPageBlobAccessTier) -> Self {
        match e {
            PremiumPageBlobAccessTier::P10 => "P10",
            PremiumPageBlobAccessTier::P15 => "P15",
            PremiumPageBlobAccessTier::P20 => "P20",
            PremiumPageBlobAccessTier::P30 => "P30",
            PremiumPageBlobAccessTier::P4 => "P4",
            PremiumPageBlobAccessTier::P40 => "P40",
            PremiumPageBlobAccessTier::P50 => "P50",
            PremiumPageBlobAccessTier::P6 => "P6",
            PremiumPageBlobAccessTier::P60 => "P60",
            PremiumPageBlobAccessTier::P70 => "P70",
            PremiumPageBlobAccessTier::P80 => "P80",
            PremiumPageBlobAccessTier::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for PremiumPageBlobAccessTier {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "P10" => PremiumPageBlobAccessTier::P10,
            "P15" => PremiumPageBlobAccessTier::P15,
            "P20" => PremiumPageBlobAccessTier::P20,
            "P30" => PremiumPageBlobAccessTier::P30,
            "P4" => PremiumPageBlobAccessTier::P4,
            "P40" => PremiumPageBlobAccessTier::P40,
            "P50" => PremiumPageBlobAccessTier::P50,
            "P6" => PremiumPageBlobAccessTier::P6,
            "P60" => PremiumPageBlobAccessTier::P60,
            "P70" => PremiumPageBlobAccessTier::P70,
            "P80" => PremiumPageBlobAccessTier::P80,
            _ => PremiumPageBlobAccessTier::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for PremiumPageBlobAccessTier {
    fn as_ref(&self) -> &str {
        match self {
            PremiumPageBlobAccessTier::P10 => "P10",
            PremiumPageBlobAccessTier::P15 => "P15",
            PremiumPageBlobAccessTier::P20 => "P20",
            PremiumPageBlobAccessTier::P30 => "P30",
            PremiumPageBlobAccessTier::P4 => "P4",
            PremiumPageBlobAccessTier::P40 => "P40",
            PremiumPageBlobAccessTier::P50 => "P50",
            PremiumPageBlobAccessTier::P6 => "P6",
            PremiumPageBlobAccessTier::P60 => "P60",
            PremiumPageBlobAccessTier::P70 => "P70",
            PremiumPageBlobAccessTier::P80 => "P80",
            PremiumPageBlobAccessTier::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for PremiumPageBlobAccessTier {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            PremiumPageBlobAccessTier::P10 => f.write_str("P10"),
            PremiumPageBlobAccessTier::P15 => f.write_str("P15"),
            PremiumPageBlobAccessTier::P20 => f.write_str("P20"),
            PremiumPageBlobAccessTier::P30 => f.write_str("P30"),
            PremiumPageBlobAccessTier::P4 => f.write_str("P4"),
            PremiumPageBlobAccessTier::P40 => f.write_str("P40"),
            PremiumPageBlobAccessTier::P50 => f.write_str("P50"),
            PremiumPageBlobAccessTier::P6 => f.write_str("P6"),
            PremiumPageBlobAccessTier::P60 => f.write_str("P60"),
            PremiumPageBlobAccessTier::P70 => f.write_str("P70"),
            PremiumPageBlobAccessTier::P80 => f.write_str("P80"),
            PremiumPageBlobAccessTier::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a PublicAccessType> for &'a str {
    fn from(e: &'a PublicAccessType) -> Self {
        match e {
            PublicAccessType::Blob => "blob",
            PublicAccessType::Container => "container",
            PublicAccessType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for PublicAccessType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "blob" => PublicAccessType::Blob,
            "container" => PublicAccessType::Container,
            _ => PublicAccessType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for PublicAccessType {
    fn as_ref(&self) -> &str {
        match self {
            PublicAccessType::Blob => "blob",
            PublicAccessType::Container => "container",
            PublicAccessType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for PublicAccessType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            PublicAccessType::Blob => f.write_str("blob"),
            PublicAccessType::Container => f.write_str("container"),
            PublicAccessType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a QueryRequestType> for &'a str {
    fn from(e: &'a QueryRequestType) -> Self {
        match e {
            QueryRequestType::Sql => "SQL",
            QueryRequestType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for QueryRequestType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "SQL" => QueryRequestType::Sql,
            _ => QueryRequestType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for QueryRequestType {
    fn as_ref(&self) -> &str {
        match self {
            QueryRequestType::Sql => "SQL",
            QueryRequestType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for QueryRequestType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            QueryRequestType::Sql => f.write_str("SQL"),
            QueryRequestType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a QueryType> for &'a str {
    fn from(e: &'a QueryType) -> Self {
        match e {
            QueryType::Arrow => "arrow",
            QueryType::Delimited => "delimited",
            QueryType::Json => "json",
            QueryType::Parquet => "parquet",
            QueryType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for QueryType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "arrow" => QueryType::Arrow,
            "delimited" => QueryType::Delimited,
            "json" => QueryType::Json,
            "parquet" => QueryType::Parquet,
            _ => QueryType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for QueryType {
    fn as_ref(&self) -> &str {
        match self {
            QueryType::Arrow => "arrow",
            QueryType::Delimited => "delimited",
            QueryType::Json => "json",
            QueryType::Parquet => "parquet",
            QueryType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for QueryType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            QueryType::Arrow => f.write_str("arrow"),
            QueryType::Delimited => f.write_str("delimited"),
            QueryType::Json => f.write_str("json"),
            QueryType::Parquet => f.write_str("parquet"),
            QueryType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a RehydratePriority> for &'a str {
    fn from(e: &'a RehydratePriority) -> Self {
        match e {
            RehydratePriority::High => "High",
            RehydratePriority::Standard => "Standard",
            RehydratePriority::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for RehydratePriority {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "High" => RehydratePriority::High,
            "Standard" => RehydratePriority::Standard,
            _ => RehydratePriority::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for RehydratePriority {
    fn as_ref(&self) -> &str {
        match self {
            RehydratePriority::High => "High",
            RehydratePriority::Standard => "Standard",
            RehydratePriority::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for RehydratePriority {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            RehydratePriority::High => f.write_str("High"),
            RehydratePriority::Standard => f.write_str("Standard"),
            RehydratePriority::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a SequenceNumberActionType> for &'a str {
    fn from(e: &'a SequenceNumberActionType) -> Self {
        match e {
            SequenceNumberActionType::Increment => "increment",
            SequenceNumberActionType::Max => "max",
            SequenceNumberActionType::Update => "update",
            SequenceNumberActionType::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for SequenceNumberActionType {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "increment" => SequenceNumberActionType::Increment,
            "max" => SequenceNumberActionType::Max,
            "update" => SequenceNumberActionType::Update,
            _ => SequenceNumberActionType::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for SequenceNumberActionType {
    fn as_ref(&self) -> &str {
        match self {
            SequenceNumberActionType::Increment => "increment",
            SequenceNumberActionType::Max => "max",
            SequenceNumberActionType::Update => "update",
            SequenceNumberActionType::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for SequenceNumberActionType {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            SequenceNumberActionType::Increment => f.write_str("increment"),
            SequenceNumberActionType::Max => f.write_str("max"),
            SequenceNumberActionType::Update => f.write_str("update"),
            SequenceNumberActionType::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a SkuName> for &'a str {
    fn from(e: &'a SkuName) -> Self {
        match e {
            SkuName::PremiumLrs => "Premium_LRS",
            SkuName::StandardGrs => "Standard_GRS",
            SkuName::StandardLrs => "Standard_LRS",
            SkuName::StandardRagrs => "Standard_RAGRS",
            SkuName::StandardZrs => "Standard_ZRS",
            SkuName::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for SkuName {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "Premium_LRS" => SkuName::PremiumLrs,
            "Standard_GRS" => SkuName::StandardGrs,
            "Standard_LRS" => SkuName::StandardLrs,
            "Standard_RAGRS" => SkuName::StandardRagrs,
            "Standard_ZRS" => SkuName::StandardZrs,
            _ => SkuName::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for SkuName {
    fn as_ref(&self) -> &str {
        match self {
            SkuName::PremiumLrs => "Premium_LRS",
            SkuName::StandardGrs => "Standard_GRS",
            SkuName::StandardLrs => "Standard_LRS",
            SkuName::StandardRagrs => "Standard_RAGRS",
            SkuName::StandardZrs => "Standard_ZRS",
            SkuName::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for SkuName {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            SkuName::PremiumLrs => f.write_str("Premium_LRS"),
            SkuName::StandardGrs => f.write_str("Standard_GRS"),
            SkuName::StandardLrs => f.write_str("Standard_LRS"),
            SkuName::StandardRagrs => f.write_str("Standard_RAGRS"),
            SkuName::StandardZrs => f.write_str("Standard_ZRS"),
            SkuName::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}
