// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

pub mod option_hashmap_encoded_bytes_std {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::{collections::HashMap, result::Result};

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Option<HashMap<String, Vec<u8>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<HashMap<String, String>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <HashMap<String, Vec<u8>>>::new();
                for kv in to_deserialize {
                    decoded0.insert(
                        kv.0,
                        base64::decode(kv.1).map_err(serde::de::Error::custom)?,
                    );
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<HashMap<String, Vec<u8>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let mut encoded0 = <HashMap<&String, String>>::new();
            for kv in to_serialize {
                encoded0.insert(kv.0, base64::encode(kv.1));
            }
            <Option<HashMap<&String, String>>>::serialize(&Some(encoded0), serializer)
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_hashmap_encoded_bytes_url {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::{collections::HashMap, result::Result};

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Option<HashMap<String, Vec<u8>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<HashMap<String, String>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <HashMap<String, Vec<u8>>>::new();
                for kv in to_deserialize {
                    decoded0.insert(
                        kv.0,
                        base64::decode_url_safe(kv.1).map_err(serde::de::Error::custom)?,
                    );
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<HashMap<String, Vec<u8>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let mut encoded0 = <HashMap<&String, String>>::new();
            for kv in to_serialize {
                encoded0.insert(kv.0, base64::encode_url_safe(kv.1));
            }
            <Option<HashMap<&String, String>>>::serialize(&Some(encoded0), serializer)
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_hashmap_hashmap_encoded_bytes_std {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::{collections::HashMap, result::Result};

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Option<HashMap<String, HashMap<String, Vec<u8>>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize =
            <Option<HashMap<String, HashMap<String, String>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <HashMap<String, HashMap<String, Vec<u8>>>>::new();
                for kv in to_deserialize {
                    let mut decoded1 = <HashMap<String, Vec<u8>>>::new();
                    for kv in kv.1 {
                        decoded1.insert(
                            kv.0,
                            base64::decode(kv.1).map_err(serde::de::Error::custom)?,
                        );
                    }
                    decoded0.insert(kv.0, decoded1);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<HashMap<String, HashMap<String, Vec<u8>>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let mut encoded0 = <HashMap<&String, HashMap<&String, String>>>::new();
            for kv in to_serialize {
                let mut encoded1 = <HashMap<&String, String>>::new();
                for kv in kv.1 {
                    encoded1.insert(kv.0, base64::encode(kv.1));
                }
                encoded0.insert(kv.0, encoded1);
            }
            <Option<HashMap<&String, HashMap<&String, String>>>>::serialize(
                &Some(encoded0),
                serializer,
            )
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_hashmap_hashmap_encoded_bytes_url {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::{collections::HashMap, result::Result};

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Option<HashMap<String, HashMap<String, Vec<u8>>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize =
            <Option<HashMap<String, HashMap<String, String>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <HashMap<String, HashMap<String, Vec<u8>>>>::new();
                for kv in to_deserialize {
                    let mut decoded1 = <HashMap<String, Vec<u8>>>::new();
                    for kv in kv.1 {
                        decoded1.insert(
                            kv.0,
                            base64::decode_url_safe(kv.1).map_err(serde::de::Error::custom)?,
                        );
                    }
                    decoded0.insert(kv.0, decoded1);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<HashMap<String, HashMap<String, Vec<u8>>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let mut encoded0 = <HashMap<&String, HashMap<&String, String>>>::new();
            for kv in to_serialize {
                let mut encoded1 = <HashMap<&String, String>>::new();
                for kv in kv.1 {
                    encoded1.insert(kv.0, base64::encode_url_safe(kv.1));
                }
                encoded0.insert(kv.0, encoded1);
            }
            <Option<HashMap<&String, HashMap<&String, String>>>>::serialize(
                &Some(encoded0),
                serializer,
            )
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_hashmap_hashmap_hashmap_encoded_bytes_std {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::{collections::HashMap, result::Result};

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Option<HashMap<String, HashMap<String, HashMap<String, Vec<u8>>>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize =
            <Option<HashMap<String, HashMap<String, HashMap<String, String>>>>>::deserialize(
                deserializer,
            )?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 =
                    <HashMap<String, HashMap<String, HashMap<String, Vec<u8>>>>>::new();
                for kv in to_deserialize {
                    let mut decoded1 = <HashMap<String, HashMap<String, Vec<u8>>>>::new();
                    for kv in kv.1 {
                        let mut decoded2 = <HashMap<String, Vec<u8>>>::new();
                        for kv in kv.1 {
                            decoded2.insert(
                                kv.0,
                                base64::decode(kv.1).map_err(serde::de::Error::custom)?,
                            );
                        }
                        decoded1.insert(kv.0, decoded2);
                    }
                    decoded0.insert(kv.0, decoded1);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<HashMap<String, HashMap<String, HashMap<String, Vec<u8>>>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let mut encoded0 =
                <HashMap<&String, HashMap<&String, HashMap<&String, String>>>>::new();
            for kv in to_serialize {
                let mut encoded1 = <HashMap<&String, HashMap<&String, String>>>::new();
                for kv in kv.1 {
                    let mut encoded2 = <HashMap<&String, String>>::new();
                    for kv in kv.1 {
                        encoded2.insert(kv.0, base64::encode(kv.1));
                    }
                    encoded1.insert(kv.0, encoded2);
                }
                encoded0.insert(kv.0, encoded1);
            }
            <Option<HashMap<&String, HashMap<&String, HashMap<&String, String>>>>>::serialize(
                &Some(encoded0),
                serializer,
            )
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_hashmap_hashmap_hashmap_encoded_bytes_url {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::{collections::HashMap, result::Result};

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Option<HashMap<String, HashMap<String, HashMap<String, Vec<u8>>>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize =
            <Option<HashMap<String, HashMap<String, HashMap<String, String>>>>>::deserialize(
                deserializer,
            )?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 =
                    <HashMap<String, HashMap<String, HashMap<String, Vec<u8>>>>>::new();
                for kv in to_deserialize {
                    let mut decoded1 = <HashMap<String, HashMap<String, Vec<u8>>>>::new();
                    for kv in kv.1 {
                        let mut decoded2 = <HashMap<String, Vec<u8>>>::new();
                        for kv in kv.1 {
                            decoded2.insert(
                                kv.0,
                                base64::decode_url_safe(kv.1).map_err(serde::de::Error::custom)?,
                            );
                        }
                        decoded1.insert(kv.0, decoded2);
                    }
                    decoded0.insert(kv.0, decoded1);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<HashMap<String, HashMap<String, HashMap<String, Vec<u8>>>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let mut encoded0 =
                <HashMap<&String, HashMap<&String, HashMap<&String, String>>>>::new();
            for kv in to_serialize {
                let mut encoded1 = <HashMap<&String, HashMap<&String, String>>>::new();
                for kv in kv.1 {
                    let mut encoded2 = <HashMap<&String, String>>::new();
                    for kv in kv.1 {
                        encoded2.insert(kv.0, base64::encode_url_safe(kv.1));
                    }
                    encoded1.insert(kv.0, encoded2);
                }
                encoded0.insert(kv.0, encoded1);
            }
            <Option<HashMap<&String, HashMap<&String, HashMap<&String, String>>>>>::serialize(
                &Some(encoded0),
                serializer,
            )
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_hashmap_hashmap_hashmap_offset_date_time_rfc3339 {
    #![allow(clippy::type_complexity)]
    use azure_core::date;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::{collections::HashMap, result::Result};
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Option<HashMap<String, HashMap<String, HashMap<String, OffsetDateTime>>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize =
            <Option<HashMap<String, HashMap<String, HashMap<String, String>>>>>::deserialize(
                deserializer,
            )?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 =
                    <HashMap<String, HashMap<String, HashMap<String, OffsetDateTime>>>>::new();
                for kv in to_deserialize {
                    let mut decoded1 = <HashMap<String, HashMap<String, OffsetDateTime>>>::new();
                    for kv in kv.1 {
                        let mut decoded2 = <HashMap<String, OffsetDateTime>>::new();
                        for kv in kv.1 {
                            decoded2.insert(
                                kv.0,
                                date::parse_rfc3339(&kv.1).map_err(serde::de::Error::custom)?,
                            );
                        }
                        decoded1.insert(kv.0, decoded2);
                    }
                    decoded0.insert(kv.0, decoded1);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<HashMap<String, HashMap<String, HashMap<String, OffsetDateTime>>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let mut encoded0 =
                <HashMap<&String, HashMap<&String, HashMap<&String, String>>>>::new();
            for kv in to_serialize {
                let mut encoded1 = <HashMap<&String, HashMap<&String, String>>>::new();
                for kv in kv.1 {
                    let mut encoded2 = <HashMap<&String, String>>::new();
                    for kv in kv.1 {
                        encoded2.insert(kv.0, date::to_rfc3339(kv.1));
                    }
                    encoded1.insert(kv.0, encoded2);
                }
                encoded0.insert(kv.0, encoded1);
            }
            <Option<HashMap<&String, HashMap<&String, HashMap<&String, String>>>>>::serialize(
                &Some(encoded0),
                serializer,
            )
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_hashmap_hashmap_hashmap_offset_date_time_rfc7231 {
    #![allow(clippy::type_complexity)]
    use azure_core::date;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::{collections::HashMap, result::Result};
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Option<HashMap<String, HashMap<String, HashMap<String, OffsetDateTime>>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize =
            <Option<HashMap<String, HashMap<String, HashMap<String, String>>>>>::deserialize(
                deserializer,
            )?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 =
                    <HashMap<String, HashMap<String, HashMap<String, OffsetDateTime>>>>::new();
                for kv in to_deserialize {
                    let mut decoded1 = <HashMap<String, HashMap<String, OffsetDateTime>>>::new();
                    for kv in kv.1 {
                        let mut decoded2 = <HashMap<String, OffsetDateTime>>::new();
                        for kv in kv.1 {
                            decoded2.insert(
                                kv.0,
                                date::parse_rfc7231(&kv.1).map_err(serde::de::Error::custom)?,
                            );
                        }
                        decoded1.insert(kv.0, decoded2);
                    }
                    decoded0.insert(kv.0, decoded1);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<HashMap<String, HashMap<String, HashMap<String, OffsetDateTime>>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let mut encoded0 =
                <HashMap<&String, HashMap<&String, HashMap<&String, String>>>>::new();
            for kv in to_serialize {
                let mut encoded1 = <HashMap<&String, HashMap<&String, String>>>::new();
                for kv in kv.1 {
                    let mut encoded2 = <HashMap<&String, String>>::new();
                    for kv in kv.1 {
                        encoded2.insert(kv.0, date::to_rfc7231(kv.1));
                    }
                    encoded1.insert(kv.0, encoded2);
                }
                encoded0.insert(kv.0, encoded1);
            }
            <Option<HashMap<&String, HashMap<&String, HashMap<&String, String>>>>>::serialize(
                &Some(encoded0),
                serializer,
            )
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_hashmap_hashmap_hashmap_offset_date_time_unix_time {
    #![allow(clippy::type_complexity)]
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::{collections::HashMap, result::Result};
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Option<HashMap<String, HashMap<String, HashMap<String, OffsetDateTime>>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize =
            <Option<HashMap<String, HashMap<String, HashMap<String, i64>>>>>::deserialize(
                deserializer,
            )?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 =
                    <HashMap<String, HashMap<String, HashMap<String, OffsetDateTime>>>>::new();
                for kv in to_deserialize {
                    let mut decoded1 = <HashMap<String, HashMap<String, OffsetDateTime>>>::new();
                    for kv in kv.1 {
                        let mut decoded2 = <HashMap<String, OffsetDateTime>>::new();
                        for kv in kv.1 {
                            decoded2.insert(
                                kv.0,
                                OffsetDateTime::from_unix_timestamp(kv.1)
                                    .map_err(serde::de::Error::custom)?,
                            );
                        }
                        decoded1.insert(kv.0, decoded2);
                    }
                    decoded0.insert(kv.0, decoded1);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<HashMap<String, HashMap<String, HashMap<String, OffsetDateTime>>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let mut encoded0 = <HashMap<&String, HashMap<&String, HashMap<&String, i64>>>>::new();
            for kv in to_serialize {
                let mut encoded1 = <HashMap<&String, HashMap<&String, i64>>>::new();
                for kv in kv.1 {
                    let mut encoded2 = <HashMap<&String, i64>>::new();
                    for kv in kv.1 {
                        encoded2.insert(kv.0, kv.1.unix_timestamp());
                    }
                    encoded1.insert(kv.0, encoded2);
                }
                encoded0.insert(kv.0, encoded1);
            }
            <Option<HashMap<&String, HashMap<&String, HashMap<&String, i64>>>>>::serialize(
                &Some(encoded0),
                serializer,
            )
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_hashmap_hashmap_offset_date_time_rfc3339 {
    #![allow(clippy::type_complexity)]
    use azure_core::date;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::{collections::HashMap, result::Result};
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Option<HashMap<String, HashMap<String, OffsetDateTime>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize =
            <Option<HashMap<String, HashMap<String, String>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <HashMap<String, HashMap<String, OffsetDateTime>>>::new();
                for kv in to_deserialize {
                    let mut decoded1 = <HashMap<String, OffsetDateTime>>::new();
                    for kv in kv.1 {
                        decoded1.insert(
                            kv.0,
                            date::parse_rfc3339(&kv.1).map_err(serde::de::Error::custom)?,
                        );
                    }
                    decoded0.insert(kv.0, decoded1);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<HashMap<String, HashMap<String, OffsetDateTime>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let mut encoded0 = <HashMap<&String, HashMap<&String, String>>>::new();
            for kv in to_serialize {
                let mut encoded1 = <HashMap<&String, String>>::new();
                for kv in kv.1 {
                    encoded1.insert(kv.0, date::to_rfc3339(kv.1));
                }
                encoded0.insert(kv.0, encoded1);
            }
            <Option<HashMap<&String, HashMap<&String, String>>>>::serialize(
                &Some(encoded0),
                serializer,
            )
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_hashmap_hashmap_offset_date_time_rfc7231 {
    #![allow(clippy::type_complexity)]
    use azure_core::date;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::{collections::HashMap, result::Result};
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Option<HashMap<String, HashMap<String, OffsetDateTime>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize =
            <Option<HashMap<String, HashMap<String, String>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <HashMap<String, HashMap<String, OffsetDateTime>>>::new();
                for kv in to_deserialize {
                    let mut decoded1 = <HashMap<String, OffsetDateTime>>::new();
                    for kv in kv.1 {
                        decoded1.insert(
                            kv.0,
                            date::parse_rfc7231(&kv.1).map_err(serde::de::Error::custom)?,
                        );
                    }
                    decoded0.insert(kv.0, decoded1);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<HashMap<String, HashMap<String, OffsetDateTime>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let mut encoded0 = <HashMap<&String, HashMap<&String, String>>>::new();
            for kv in to_serialize {
                let mut encoded1 = <HashMap<&String, String>>::new();
                for kv in kv.1 {
                    encoded1.insert(kv.0, date::to_rfc7231(kv.1));
                }
                encoded0.insert(kv.0, encoded1);
            }
            <Option<HashMap<&String, HashMap<&String, String>>>>::serialize(
                &Some(encoded0),
                serializer,
            )
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_hashmap_hashmap_offset_date_time_unix_time {
    #![allow(clippy::type_complexity)]
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::{collections::HashMap, result::Result};
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Option<HashMap<String, HashMap<String, OffsetDateTime>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize =
            <Option<HashMap<String, HashMap<String, i64>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <HashMap<String, HashMap<String, OffsetDateTime>>>::new();
                for kv in to_deserialize {
                    let mut decoded1 = <HashMap<String, OffsetDateTime>>::new();
                    for kv in kv.1 {
                        decoded1.insert(
                            kv.0,
                            OffsetDateTime::from_unix_timestamp(kv.1)
                                .map_err(serde::de::Error::custom)?,
                        );
                    }
                    decoded0.insert(kv.0, decoded1);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<HashMap<String, HashMap<String, OffsetDateTime>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let mut encoded0 = <HashMap<&String, HashMap<&String, i64>>>::new();
            for kv in to_serialize {
                let mut encoded1 = <HashMap<&String, i64>>::new();
                for kv in kv.1 {
                    encoded1.insert(kv.0, kv.1.unix_timestamp());
                }
                encoded0.insert(kv.0, encoded1);
            }
            <Option<HashMap<&String, HashMap<&String, i64>>>>::serialize(
                &Some(encoded0),
                serializer,
            )
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_hashmap_offset_date_time_rfc3339 {
    #![allow(clippy::type_complexity)]
    use azure_core::date;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::{collections::HashMap, result::Result};
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Option<HashMap<String, OffsetDateTime>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<HashMap<String, String>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <HashMap<String, OffsetDateTime>>::new();
                for kv in to_deserialize {
                    decoded0.insert(
                        kv.0,
                        date::parse_rfc3339(&kv.1).map_err(serde::de::Error::custom)?,
                    );
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<HashMap<String, OffsetDateTime>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let mut encoded0 = <HashMap<&String, String>>::new();
            for kv in to_serialize {
                encoded0.insert(kv.0, date::to_rfc3339(kv.1));
            }
            <Option<HashMap<&String, String>>>::serialize(&Some(encoded0), serializer)
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_hashmap_offset_date_time_rfc7231 {
    #![allow(clippy::type_complexity)]
    use azure_core::date;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::{collections::HashMap, result::Result};
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Option<HashMap<String, OffsetDateTime>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<HashMap<String, String>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <HashMap<String, OffsetDateTime>>::new();
                for kv in to_deserialize {
                    decoded0.insert(
                        kv.0,
                        date::parse_rfc7231(&kv.1).map_err(serde::de::Error::custom)?,
                    );
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<HashMap<String, OffsetDateTime>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let mut encoded0 = <HashMap<&String, String>>::new();
            for kv in to_serialize {
                encoded0.insert(kv.0, date::to_rfc7231(kv.1));
            }
            <Option<HashMap<&String, String>>>::serialize(&Some(encoded0), serializer)
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_hashmap_offset_date_time_unix_time {
    #![allow(clippy::type_complexity)]
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::{collections::HashMap, result::Result};
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Option<HashMap<String, OffsetDateTime>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<HashMap<String, i64>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <HashMap<String, OffsetDateTime>>::new();
                for kv in to_deserialize {
                    decoded0.insert(
                        kv.0,
                        OffsetDateTime::from_unix_timestamp(kv.1)
                            .map_err(serde::de::Error::custom)?,
                    );
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<HashMap<String, OffsetDateTime>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let mut encoded0 = <HashMap<&String, i64>>::new();
            for kv in to_serialize {
                encoded0.insert(kv.0, kv.1.unix_timestamp());
            }
            <Option<HashMap<&String, i64>>>::serialize(&Some(encoded0), serializer)
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_hashmap_vec_encoded_bytes_std {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::{collections::HashMap, result::Result};

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Option<HashMap<String, Vec<Vec<u8>>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<HashMap<String, Vec<String>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <HashMap<String, Vec<Vec<u8>>>>::new();
                for kv in to_deserialize {
                    let mut decoded1 = <Vec<Vec<u8>>>::new();
                    for v in kv.1 {
                        decoded1.push(base64::decode(v).map_err(serde::de::Error::custom)?);
                    }
                    decoded0.insert(kv.0, decoded1);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<HashMap<String, Vec<Vec<u8>>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let mut encoded0 = <HashMap<&String, Vec<String>>>::new();
            for kv in to_serialize {
                encoded0.insert(kv.0, kv.1.iter().map(base64::encode).collect());
            }
            <Option<HashMap<&String, Vec<String>>>>::serialize(&Some(encoded0), serializer)
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_hashmap_vec_encoded_bytes_url {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::{collections::HashMap, result::Result};

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Option<HashMap<String, Vec<Vec<u8>>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<HashMap<String, Vec<String>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <HashMap<String, Vec<Vec<u8>>>>::new();
                for kv in to_deserialize {
                    let mut decoded1 = <Vec<Vec<u8>>>::new();
                    for v in kv.1 {
                        decoded1
                            .push(base64::decode_url_safe(v).map_err(serde::de::Error::custom)?);
                    }
                    decoded0.insert(kv.0, decoded1);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<HashMap<String, Vec<Vec<u8>>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let mut encoded0 = <HashMap<&String, Vec<String>>>::new();
            for kv in to_serialize {
                encoded0.insert(kv.0, kv.1.iter().map(base64::encode_url_safe).collect());
            }
            <Option<HashMap<&String, Vec<String>>>>::serialize(&Some(encoded0), serializer)
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_hashmap_vec_offset_date_time_rfc7231 {
    #![allow(clippy::type_complexity)]
    use azure_core::date;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::{collections::HashMap, result::Result};
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Option<HashMap<String, Vec<OffsetDateTime>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<HashMap<String, Vec<String>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <HashMap<String, Vec<OffsetDateTime>>>::new();
                for kv in to_deserialize {
                    let mut decoded1 = <Vec<OffsetDateTime>>::new();
                    for v in kv.1 {
                        decoded1.push(date::parse_rfc7231(&v).map_err(serde::de::Error::custom)?);
                    }
                    decoded0.insert(kv.0, decoded1);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<HashMap<String, Vec<OffsetDateTime>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let mut encoded0 = <HashMap<&String, Vec<String>>>::new();
            for kv in to_serialize {
                encoded0.insert(kv.0, kv.1.iter().map(date::to_rfc7231).collect());
            }
            <Option<HashMap<&String, Vec<String>>>>::serialize(&Some(encoded0), serializer)
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_hashmap_vec_offset_date_time_unix_time {
    #![allow(clippy::type_complexity)]
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::{collections::HashMap, result::Result};
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Option<HashMap<String, Vec<OffsetDateTime>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<HashMap<String, Vec<i64>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <HashMap<String, Vec<OffsetDateTime>>>::new();
                for kv in to_deserialize {
                    let mut decoded1 = <Vec<OffsetDateTime>>::new();
                    for v in kv.1 {
                        decoded1.push(
                            OffsetDateTime::from_unix_timestamp(v)
                                .map_err(serde::de::Error::custom)?,
                        );
                    }
                    decoded0.insert(kv.0, decoded1);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<HashMap<String, Vec<OffsetDateTime>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let mut encoded0 = <HashMap<&String, Vec<i64>>>::new();
            for kv in to_serialize {
                encoded0.insert(kv.0, kv.1.iter().map(|v| v.unix_timestamp()).collect());
            }
            <Option<HashMap<&String, Vec<i64>>>>::serialize(&Some(encoded0), serializer)
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_vec_encoded_bytes_std {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Option<Vec<Vec<u8>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<String>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<Vec<u8>>>::new();
                for v in to_deserialize {
                    decoded0.push(base64::decode(v).map_err(serde::de::Error::custom)?);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<Vec<Vec<u8>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let encoded0 = to_serialize.iter().map(base64::encode).collect();
            <Option<Vec<String>>>::serialize(&Some(encoded0), serializer)
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_vec_encoded_bytes_url {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Option<Vec<Vec<u8>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<String>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<Vec<u8>>>::new();
                for v in to_deserialize {
                    decoded0.push(base64::decode_url_safe(v).map_err(serde::de::Error::custom)?);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<Vec<Vec<u8>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let encoded0 = to_serialize.iter().map(base64::encode_url_safe).collect();
            <Option<Vec<String>>>::serialize(&Some(encoded0), serializer)
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_vec_hashmap_vec_encoded_bytes_std {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::{collections::HashMap, result::Result};

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Option<Vec<HashMap<String, Vec<Vec<u8>>>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize =
            <Option<Vec<HashMap<String, Vec<String>>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<HashMap<String, Vec<Vec<u8>>>>>::new();
                for v in to_deserialize {
                    let mut decoded1 = <HashMap<String, Vec<Vec<u8>>>>::new();
                    for kv in v {
                        let mut decoded2 = <Vec<Vec<u8>>>::new();
                        for v in kv.1 {
                            decoded2.push(base64::decode(v).map_err(serde::de::Error::custom)?);
                        }
                        decoded1.insert(kv.0, decoded2);
                    }
                    decoded0.push(decoded1);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<Vec<HashMap<String, Vec<Vec<u8>>>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let encoded0 = to_serialize
                .iter()
                .map(|v| {
                    let mut encoded1 = <HashMap<&String, Vec<String>>>::new();
                    for kv in v {
                        encoded1.insert(kv.0, kv.1.iter().map(base64::encode).collect());
                    }
                    encoded1
                })
                .collect();
            <Option<Vec<HashMap<&String, Vec<String>>>>>::serialize(&Some(encoded0), serializer)
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_vec_hashmap_vec_encoded_bytes_url {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::{collections::HashMap, result::Result};

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Option<Vec<HashMap<String, Vec<Vec<u8>>>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize =
            <Option<Vec<HashMap<String, Vec<String>>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<HashMap<String, Vec<Vec<u8>>>>>::new();
                for v in to_deserialize {
                    let mut decoded1 = <HashMap<String, Vec<Vec<u8>>>>::new();
                    for kv in v {
                        let mut decoded2 = <Vec<Vec<u8>>>::new();
                        for v in kv.1 {
                            decoded2.push(
                                base64::decode_url_safe(v).map_err(serde::de::Error::custom)?,
                            );
                        }
                        decoded1.insert(kv.0, decoded2);
                    }
                    decoded0.push(decoded1);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<Vec<HashMap<String, Vec<Vec<u8>>>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let encoded0 = to_serialize
                .iter()
                .map(|v| {
                    let mut encoded1 = <HashMap<&String, Vec<String>>>::new();
                    for kv in v {
                        encoded1.insert(kv.0, kv.1.iter().map(base64::encode_url_safe).collect());
                    }
                    encoded1
                })
                .collect();
            <Option<Vec<HashMap<&String, Vec<String>>>>>::serialize(&Some(encoded0), serializer)
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_vec_hashmap_vec_offset_date_time_rfc3339 {
    #![allow(clippy::type_complexity)]
    use azure_core::date;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::{collections::HashMap, result::Result};
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Option<Vec<HashMap<String, Vec<OffsetDateTime>>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize =
            <Option<Vec<HashMap<String, Vec<String>>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<HashMap<String, Vec<OffsetDateTime>>>>::new();
                for v in to_deserialize {
                    let mut decoded1 = <HashMap<String, Vec<OffsetDateTime>>>::new();
                    for kv in v {
                        let mut decoded2 = <Vec<OffsetDateTime>>::new();
                        for v in kv.1 {
                            decoded2
                                .push(date::parse_rfc3339(&v).map_err(serde::de::Error::custom)?);
                        }
                        decoded1.insert(kv.0, decoded2);
                    }
                    decoded0.push(decoded1);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<Vec<HashMap<String, Vec<OffsetDateTime>>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let encoded0 = to_serialize
                .iter()
                .map(|v| {
                    let mut encoded1 = <HashMap<&String, Vec<String>>>::new();
                    for kv in v {
                        encoded1.insert(kv.0, kv.1.iter().map(date::to_rfc3339).collect());
                    }
                    encoded1
                })
                .collect();
            <Option<Vec<HashMap<&String, Vec<String>>>>>::serialize(&Some(encoded0), serializer)
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_vec_hashmap_vec_offset_date_time_unix_time {
    #![allow(clippy::type_complexity)]
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::{collections::HashMap, result::Result};
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Option<Vec<HashMap<String, Vec<OffsetDateTime>>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<HashMap<String, Vec<i64>>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<HashMap<String, Vec<OffsetDateTime>>>>::new();
                for v in to_deserialize {
                    let mut decoded1 = <HashMap<String, Vec<OffsetDateTime>>>::new();
                    for kv in v {
                        let mut decoded2 = <Vec<OffsetDateTime>>::new();
                        for v in kv.1 {
                            decoded2.push(
                                OffsetDateTime::from_unix_timestamp(v)
                                    .map_err(serde::de::Error::custom)?,
                            );
                        }
                        decoded1.insert(kv.0, decoded2);
                    }
                    decoded0.push(decoded1);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<Vec<HashMap<String, Vec<OffsetDateTime>>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let encoded0 = to_serialize
                .iter()
                .map(|v| {
                    let mut encoded1 = <HashMap<&String, Vec<i64>>>::new();
                    for kv in v {
                        encoded1.insert(kv.0, kv.1.iter().map(|v| v.unix_timestamp()).collect());
                    }
                    encoded1
                })
                .collect();
            <Option<Vec<HashMap<&String, Vec<i64>>>>>::serialize(&Some(encoded0), serializer)
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_vec_offset_date_time_rfc3339 {
    #![allow(clippy::type_complexity)]
    use azure_core::date;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Option<Vec<OffsetDateTime>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<String>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<OffsetDateTime>>::new();
                for v in to_deserialize {
                    decoded0.push(date::parse_rfc3339(&v).map_err(serde::de::Error::custom)?);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<Vec<OffsetDateTime>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let encoded0 = to_serialize.iter().map(date::to_rfc3339).collect();
            <Option<Vec<String>>>::serialize(&Some(encoded0), serializer)
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_vec_offset_date_time_rfc7231 {
    #![allow(clippy::type_complexity)]
    use azure_core::date;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Option<Vec<OffsetDateTime>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<String>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<OffsetDateTime>>::new();
                for v in to_deserialize {
                    decoded0.push(date::parse_rfc7231(&v).map_err(serde::de::Error::custom)?);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<Vec<OffsetDateTime>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let encoded0 = to_serialize.iter().map(date::to_rfc7231).collect();
            <Option<Vec<String>>>::serialize(&Some(encoded0), serializer)
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_vec_offset_date_time_unix_time {
    #![allow(clippy::type_complexity)]
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Option<Vec<OffsetDateTime>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<i64>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<OffsetDateTime>>::new();
                for v in to_deserialize {
                    decoded0.push(
                        OffsetDateTime::from_unix_timestamp(v).map_err(serde::de::Error::custom)?,
                    );
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<Vec<OffsetDateTime>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let encoded0 = to_serialize.iter().map(|v| v.unix_timestamp()).collect();
            <Option<Vec<i64>>>::serialize(&Some(encoded0), serializer)
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_vec_vec_encoded_bytes_std {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Option<Vec<Vec<Vec<u8>>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<Vec<String>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<Vec<Vec<u8>>>>::new();
                for v in to_deserialize {
                    let mut decoded1 = <Vec<Vec<u8>>>::new();
                    for v in v {
                        decoded1.push(base64::decode(v).map_err(serde::de::Error::custom)?);
                    }
                    decoded0.push(decoded1);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<Vec<Vec<Vec<u8>>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let encoded0 = to_serialize
                .iter()
                .map(|v| v.iter().map(base64::encode).collect())
                .collect();
            <Option<Vec<Vec<String>>>>::serialize(&Some(encoded0), serializer)
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_vec_vec_encoded_bytes_url {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Option<Vec<Vec<Vec<u8>>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<Vec<String>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<Vec<Vec<u8>>>>::new();
                for v in to_deserialize {
                    let mut decoded1 = <Vec<Vec<u8>>>::new();
                    for v in v {
                        decoded1
                            .push(base64::decode_url_safe(v).map_err(serde::de::Error::custom)?);
                    }
                    decoded0.push(decoded1);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<Vec<Vec<Vec<u8>>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let encoded0 = to_serialize
                .iter()
                .map(|v| v.iter().map(base64::encode_url_safe).collect())
                .collect();
            <Option<Vec<Vec<String>>>>::serialize(&Some(encoded0), serializer)
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_vec_vec_offset_date_time_rfc3339 {
    #![allow(clippy::type_complexity)]
    use azure_core::date;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Option<Vec<Vec<OffsetDateTime>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<Vec<String>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<Vec<OffsetDateTime>>>::new();
                for v in to_deserialize {
                    let mut decoded1 = <Vec<OffsetDateTime>>::new();
                    for v in v {
                        decoded1.push(date::parse_rfc3339(&v).map_err(serde::de::Error::custom)?);
                    }
                    decoded0.push(decoded1);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<Vec<Vec<OffsetDateTime>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let encoded0 = to_serialize
                .iter()
                .map(|v| v.iter().map(date::to_rfc3339).collect())
                .collect();
            <Option<Vec<Vec<String>>>>::serialize(&Some(encoded0), serializer)
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_vec_vec_offset_date_time_rfc7231 {
    #![allow(clippy::type_complexity)]
    use azure_core::date;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Option<Vec<Vec<OffsetDateTime>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<Vec<String>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<Vec<OffsetDateTime>>>::new();
                for v in to_deserialize {
                    let mut decoded1 = <Vec<OffsetDateTime>>::new();
                    for v in v {
                        decoded1.push(date::parse_rfc7231(&v).map_err(serde::de::Error::custom)?);
                    }
                    decoded0.push(decoded1);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<Vec<Vec<OffsetDateTime>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let encoded0 = to_serialize
                .iter()
                .map(|v| v.iter().map(date::to_rfc7231).collect())
                .collect();
            <Option<Vec<Vec<String>>>>::serialize(&Some(encoded0), serializer)
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_vec_vec_offset_date_time_unix_time {
    #![allow(clippy::type_complexity)]
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Option<Vec<Vec<OffsetDateTime>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<Vec<i64>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<Vec<OffsetDateTime>>>::new();
                for v in to_deserialize {
                    let mut decoded1 = <Vec<OffsetDateTime>>::new();
                    for v in v {
                        decoded1.push(
                            OffsetDateTime::from_unix_timestamp(v)
                                .map_err(serde::de::Error::custom)?,
                        );
                    }
                    decoded0.push(decoded1);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<Vec<Vec<OffsetDateTime>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let encoded0 = to_serialize
                .iter()
                .map(|v| v.iter().map(|v| v.unix_timestamp()).collect())
                .collect();
            <Option<Vec<Vec<i64>>>>::serialize(&Some(encoded0), serializer)
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_vec_vec_vec_encoded_bytes_std {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Option<Vec<Vec<Vec<Vec<u8>>>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<Vec<Vec<String>>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<Vec<Vec<Vec<u8>>>>>::new();
                for v in to_deserialize {
                    let mut decoded1 = <Vec<Vec<Vec<u8>>>>::new();
                    for v in v {
                        let mut decoded2 = <Vec<Vec<u8>>>::new();
                        for v in v {
                            decoded2.push(base64::decode(v).map_err(serde::de::Error::custom)?);
                        }
                        decoded1.push(decoded2);
                    }
                    decoded0.push(decoded1);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<Vec<Vec<Vec<Vec<u8>>>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let encoded0 = to_serialize
                .iter()
                .map(|v| {
                    v.iter()
                        .map(|v| v.iter().map(base64::encode).collect())
                        .collect()
                })
                .collect();
            <Option<Vec<Vec<Vec<String>>>>>::serialize(&Some(encoded0), serializer)
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_vec_vec_vec_encoded_bytes_url {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Option<Vec<Vec<Vec<Vec<u8>>>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<Vec<Vec<String>>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<Vec<Vec<Vec<u8>>>>>::new();
                for v in to_deserialize {
                    let mut decoded1 = <Vec<Vec<Vec<u8>>>>::new();
                    for v in v {
                        let mut decoded2 = <Vec<Vec<u8>>>::new();
                        for v in v {
                            decoded2.push(
                                base64::decode_url_safe(v).map_err(serde::de::Error::custom)?,
                            );
                        }
                        decoded1.push(decoded2);
                    }
                    decoded0.push(decoded1);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<Vec<Vec<Vec<Vec<u8>>>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let encoded0 = to_serialize
                .iter()
                .map(|v| {
                    v.iter()
                        .map(|v| v.iter().map(base64::encode_url_safe).collect())
                        .collect()
                })
                .collect();
            <Option<Vec<Vec<Vec<String>>>>>::serialize(&Some(encoded0), serializer)
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_vec_vec_vec_offset_date_time_rfc3339 {
    #![allow(clippy::type_complexity)]
    use azure_core::date;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Option<Vec<Vec<Vec<OffsetDateTime>>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<Vec<Vec<String>>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<Vec<Vec<OffsetDateTime>>>>::new();
                for v in to_deserialize {
                    let mut decoded1 = <Vec<Vec<OffsetDateTime>>>::new();
                    for v in v {
                        let mut decoded2 = <Vec<OffsetDateTime>>::new();
                        for v in v {
                            decoded2
                                .push(date::parse_rfc3339(&v).map_err(serde::de::Error::custom)?);
                        }
                        decoded1.push(decoded2);
                    }
                    decoded0.push(decoded1);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<Vec<Vec<Vec<OffsetDateTime>>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let encoded0 = to_serialize
                .iter()
                .map(|v| {
                    v.iter()
                        .map(|v| v.iter().map(date::to_rfc3339).collect())
                        .collect()
                })
                .collect();
            <Option<Vec<Vec<Vec<String>>>>>::serialize(&Some(encoded0), serializer)
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_vec_vec_vec_offset_date_time_rfc7231 {
    #![allow(clippy::type_complexity)]
    use azure_core::date;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Option<Vec<Vec<Vec<OffsetDateTime>>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<Vec<Vec<String>>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<Vec<Vec<OffsetDateTime>>>>::new();
                for v in to_deserialize {
                    let mut decoded1 = <Vec<Vec<OffsetDateTime>>>::new();
                    for v in v {
                        let mut decoded2 = <Vec<OffsetDateTime>>::new();
                        for v in v {
                            decoded2
                                .push(date::parse_rfc7231(&v).map_err(serde::de::Error::custom)?);
                        }
                        decoded1.push(decoded2);
                    }
                    decoded0.push(decoded1);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<Vec<Vec<Vec<OffsetDateTime>>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let encoded0 = to_serialize
                .iter()
                .map(|v| {
                    v.iter()
                        .map(|v| v.iter().map(date::to_rfc7231).collect())
                        .collect()
                })
                .collect();
            <Option<Vec<Vec<Vec<String>>>>>::serialize(&Some(encoded0), serializer)
        } else {
            serializer.serialize_none()
        }
    }
}

pub mod option_vec_vec_vec_offset_date_time_unix_time {
    #![allow(clippy::type_complexity)]
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Option<Vec<Vec<Vec<OffsetDateTime>>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<Vec<Vec<i64>>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<Vec<Vec<OffsetDateTime>>>>::new();
                for v in to_deserialize {
                    let mut decoded1 = <Vec<Vec<OffsetDateTime>>>::new();
                    for v in v {
                        let mut decoded2 = <Vec<OffsetDateTime>>::new();
                        for v in v {
                            decoded2.push(
                                OffsetDateTime::from_unix_timestamp(v)
                                    .map_err(serde::de::Error::custom)?,
                            );
                        }
                        decoded1.push(decoded2);
                    }
                    decoded0.push(decoded1);
                }
                Ok(Some(decoded0))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S>(
        to_serialize: &Option<Vec<Vec<Vec<OffsetDateTime>>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if let Some(to_serialize) = to_serialize {
            let encoded0 = to_serialize
                .iter()
                .map(|v| {
                    v.iter()
                        .map(|v| v.iter().map(|v| v.unix_timestamp()).collect())
                        .collect()
                })
                .collect();
            <Option<Vec<Vec<Vec<i64>>>>>::serialize(&Some(encoded0), serializer)
        } else {
            serializer.serialize_none()
        }
    }
}
