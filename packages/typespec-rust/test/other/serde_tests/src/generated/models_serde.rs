// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

pub mod hashmap_encoded_bytes_std {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::collections::HashMap;
    use std::result::Result;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<HashMap<String, Vec<u8>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<HashMap<String, String>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <HashMap<String, Vec<u8>>>::new();
                for kv in to_deserialize {
                    decoded0.insert(
                        kv.0,
                        base64::decode(kv.1).map_err(serde::de::Error::custom)?,
                    );
                }
                Ok(decoded0)
            }
            None => Ok(<HashMap<String, Vec<u8>>>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &HashMap<String, Vec<u8>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut encoded0 = <HashMap<&String, String>>::new();
        for kv in to_serialize {
            encoded0.insert(kv.0, base64::encode(kv.1));
        }
        <HashMap<&String, String>>::serialize(&encoded0, serializer)
    }
}

pub mod hashmap_encoded_bytes_url {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::collections::HashMap;
    use std::result::Result;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<HashMap<String, Vec<u8>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<HashMap<String, String>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <HashMap<String, Vec<u8>>>::new();
                for kv in to_deserialize {
                    decoded0.insert(
                        kv.0,
                        base64::decode_url_safe(kv.1).map_err(serde::de::Error::custom)?,
                    );
                }
                Ok(decoded0)
            }
            None => Ok(<HashMap<String, Vec<u8>>>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &HashMap<String, Vec<u8>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut encoded0 = <HashMap<&String, String>>::new();
        for kv in to_serialize {
            encoded0.insert(kv.0, base64::encode_url_safe(kv.1));
        }
        <HashMap<&String, String>>::serialize(&encoded0, serializer)
    }
}

pub mod hashmap_hashmap_encoded_bytes_std {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::collections::HashMap;
    use std::result::Result;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<HashMap<String, HashMap<String, Vec<u8>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize =
            <Option<HashMap<String, HashMap<String, String>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <HashMap<String, HashMap<String, Vec<u8>>>>::new();
                for kv in to_deserialize {
                    let mut decoded1 = <HashMap<String, Vec<u8>>>::new();
                    for kv in kv.1 {
                        decoded1.insert(
                            kv.0,
                            base64::decode(kv.1).map_err(serde::de::Error::custom)?,
                        );
                    }
                    decoded0.insert(kv.0, decoded1);
                }
                Ok(decoded0)
            }
            None => Ok(<HashMap<String, HashMap<String, Vec<u8>>>>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &HashMap<String, HashMap<String, Vec<u8>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut encoded0 = <HashMap<&String, HashMap<&String, String>>>::new();
        for kv in to_serialize {
            let mut encoded1 = <HashMap<&String, String>>::new();
            for kv in kv.1 {
                encoded1.insert(kv.0, base64::encode(kv.1));
            }
            encoded0.insert(kv.0, encoded1);
        }
        <HashMap<&String, HashMap<&String, String>>>::serialize(&encoded0, serializer)
    }
}

pub mod hashmap_hashmap_encoded_bytes_url {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::collections::HashMap;
    use std::result::Result;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<HashMap<String, HashMap<String, Vec<u8>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize =
            <Option<HashMap<String, HashMap<String, String>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <HashMap<String, HashMap<String, Vec<u8>>>>::new();
                for kv in to_deserialize {
                    let mut decoded1 = <HashMap<String, Vec<u8>>>::new();
                    for kv in kv.1 {
                        decoded1.insert(
                            kv.0,
                            base64::decode_url_safe(kv.1).map_err(serde::de::Error::custom)?,
                        );
                    }
                    decoded0.insert(kv.0, decoded1);
                }
                Ok(decoded0)
            }
            None => Ok(<HashMap<String, HashMap<String, Vec<u8>>>>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &HashMap<String, HashMap<String, Vec<u8>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut encoded0 = <HashMap<&String, HashMap<&String, String>>>::new();
        for kv in to_serialize {
            let mut encoded1 = <HashMap<&String, String>>::new();
            for kv in kv.1 {
                encoded1.insert(kv.0, base64::encode_url_safe(kv.1));
            }
            encoded0.insert(kv.0, encoded1);
        }
        <HashMap<&String, HashMap<&String, String>>>::serialize(&encoded0, serializer)
    }
}

pub mod hashmap_hashmap_hashmap_encoded_bytes_std {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::collections::HashMap;
    use std::result::Result;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<HashMap<String, HashMap<String, HashMap<String, Vec<u8>>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize =
            <Option<HashMap<String, HashMap<String, HashMap<String, String>>>>>::deserialize(
                deserializer,
            )?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 =
                    <HashMap<String, HashMap<String, HashMap<String, Vec<u8>>>>>::new();
                for kv in to_deserialize {
                    let mut decoded1 = <HashMap<String, HashMap<String, Vec<u8>>>>::new();
                    for kv in kv.1 {
                        let mut decoded2 = <HashMap<String, Vec<u8>>>::new();
                        for kv in kv.1 {
                            decoded2.insert(
                                kv.0,
                                base64::decode(kv.1).map_err(serde::de::Error::custom)?,
                            );
                        }
                        decoded1.insert(kv.0, decoded2);
                    }
                    decoded0.insert(kv.0, decoded1);
                }
                Ok(decoded0)
            }
            None => Ok(<HashMap<String, HashMap<String, HashMap<String, Vec<u8>>>>>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &HashMap<String, HashMap<String, HashMap<String, Vec<u8>>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut encoded0 = <HashMap<&String, HashMap<&String, HashMap<&String, String>>>>::new();
        for kv in to_serialize {
            let mut encoded1 = <HashMap<&String, HashMap<&String, String>>>::new();
            for kv in kv.1 {
                let mut encoded2 = <HashMap<&String, String>>::new();
                for kv in kv.1 {
                    encoded2.insert(kv.0, base64::encode(kv.1));
                }
                encoded1.insert(kv.0, encoded2);
            }
            encoded0.insert(kv.0, encoded1);
        }
        <HashMap<&String, HashMap<&String, HashMap<&String, String>>>>::serialize(
            &encoded0, serializer,
        )
    }
}

pub mod hashmap_hashmap_hashmap_encoded_bytes_url {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::collections::HashMap;
    use std::result::Result;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<HashMap<String, HashMap<String, HashMap<String, Vec<u8>>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize =
            <Option<HashMap<String, HashMap<String, HashMap<String, String>>>>>::deserialize(
                deserializer,
            )?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 =
                    <HashMap<String, HashMap<String, HashMap<String, Vec<u8>>>>>::new();
                for kv in to_deserialize {
                    let mut decoded1 = <HashMap<String, HashMap<String, Vec<u8>>>>::new();
                    for kv in kv.1 {
                        let mut decoded2 = <HashMap<String, Vec<u8>>>::new();
                        for kv in kv.1 {
                            decoded2.insert(
                                kv.0,
                                base64::decode_url_safe(kv.1).map_err(serde::de::Error::custom)?,
                            );
                        }
                        decoded1.insert(kv.0, decoded2);
                    }
                    decoded0.insert(kv.0, decoded1);
                }
                Ok(decoded0)
            }
            None => Ok(<HashMap<String, HashMap<String, HashMap<String, Vec<u8>>>>>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &HashMap<String, HashMap<String, HashMap<String, Vec<u8>>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut encoded0 = <HashMap<&String, HashMap<&String, HashMap<&String, String>>>>::new();
        for kv in to_serialize {
            let mut encoded1 = <HashMap<&String, HashMap<&String, String>>>::new();
            for kv in kv.1 {
                let mut encoded2 = <HashMap<&String, String>>::new();
                for kv in kv.1 {
                    encoded2.insert(kv.0, base64::encode_url_safe(kv.1));
                }
                encoded1.insert(kv.0, encoded2);
            }
            encoded0.insert(kv.0, encoded1);
        }
        <HashMap<&String, HashMap<&String, HashMap<&String, String>>>>::serialize(
            &encoded0, serializer,
        )
    }
}

pub mod hashmap_hashmap_hashmap_offset_date_time_rfc3339 {
    #![allow(clippy::type_complexity)]
    use azure_core::date;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::collections::HashMap;
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<HashMap<String, HashMap<String, HashMap<String, OffsetDateTime>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize =
            <Option<HashMap<String, HashMap<String, HashMap<String, String>>>>>::deserialize(
                deserializer,
            )?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 =
                    <HashMap<String, HashMap<String, HashMap<String, OffsetDateTime>>>>::new();
                for kv in to_deserialize {
                    let mut decoded1 = <HashMap<String, HashMap<String, OffsetDateTime>>>::new();
                    for kv in kv.1 {
                        let mut decoded2 = <HashMap<String, OffsetDateTime>>::new();
                        for kv in kv.1 {
                            decoded2.insert(
                                kv.0,
                                date::parse_rfc3339(&kv.1).map_err(serde::de::Error::custom)?,
                            );
                        }
                        decoded1.insert(kv.0, decoded2);
                    }
                    decoded0.insert(kv.0, decoded1);
                }
                Ok(decoded0)
            }
            None => Ok(<HashMap<
                String,
                HashMap<String, HashMap<String, OffsetDateTime>>,
            >>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &HashMap<String, HashMap<String, HashMap<String, OffsetDateTime>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut encoded0 = <HashMap<&String, HashMap<&String, HashMap<&String, String>>>>::new();
        for kv in to_serialize {
            let mut encoded1 = <HashMap<&String, HashMap<&String, String>>>::new();
            for kv in kv.1 {
                let mut encoded2 = <HashMap<&String, String>>::new();
                for kv in kv.1 {
                    encoded2.insert(kv.0, date::to_rfc3339(kv.1));
                }
                encoded1.insert(kv.0, encoded2);
            }
            encoded0.insert(kv.0, encoded1);
        }
        <HashMap<&String, HashMap<&String, HashMap<&String, String>>>>::serialize(
            &encoded0, serializer,
        )
    }
}

pub mod hashmap_hashmap_hashmap_offset_date_time_rfc7231 {
    #![allow(clippy::type_complexity)]
    use azure_core::date;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::collections::HashMap;
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<HashMap<String, HashMap<String, HashMap<String, OffsetDateTime>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize =
            <Option<HashMap<String, HashMap<String, HashMap<String, String>>>>>::deserialize(
                deserializer,
            )?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 =
                    <HashMap<String, HashMap<String, HashMap<String, OffsetDateTime>>>>::new();
                for kv in to_deserialize {
                    let mut decoded1 = <HashMap<String, HashMap<String, OffsetDateTime>>>::new();
                    for kv in kv.1 {
                        let mut decoded2 = <HashMap<String, OffsetDateTime>>::new();
                        for kv in kv.1 {
                            decoded2.insert(
                                kv.0,
                                date::parse_rfc7231(&kv.1).map_err(serde::de::Error::custom)?,
                            );
                        }
                        decoded1.insert(kv.0, decoded2);
                    }
                    decoded0.insert(kv.0, decoded1);
                }
                Ok(decoded0)
            }
            None => Ok(<HashMap<
                String,
                HashMap<String, HashMap<String, OffsetDateTime>>,
            >>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &HashMap<String, HashMap<String, HashMap<String, OffsetDateTime>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut encoded0 = <HashMap<&String, HashMap<&String, HashMap<&String, String>>>>::new();
        for kv in to_serialize {
            let mut encoded1 = <HashMap<&String, HashMap<&String, String>>>::new();
            for kv in kv.1 {
                let mut encoded2 = <HashMap<&String, String>>::new();
                for kv in kv.1 {
                    encoded2.insert(kv.0, date::to_rfc7231(kv.1));
                }
                encoded1.insert(kv.0, encoded2);
            }
            encoded0.insert(kv.0, encoded1);
        }
        <HashMap<&String, HashMap<&String, HashMap<&String, String>>>>::serialize(
            &encoded0, serializer,
        )
    }
}

pub mod hashmap_hashmap_hashmap_offset_date_time_unix_time {
    #![allow(clippy::type_complexity)]
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::collections::HashMap;
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<HashMap<String, HashMap<String, HashMap<String, OffsetDateTime>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize =
            <Option<HashMap<String, HashMap<String, HashMap<String, i64>>>>>::deserialize(
                deserializer,
            )?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 =
                    <HashMap<String, HashMap<String, HashMap<String, OffsetDateTime>>>>::new();
                for kv in to_deserialize {
                    let mut decoded1 = <HashMap<String, HashMap<String, OffsetDateTime>>>::new();
                    for kv in kv.1 {
                        let mut decoded2 = <HashMap<String, OffsetDateTime>>::new();
                        for kv in kv.1 {
                            decoded2.insert(
                                kv.0,
                                OffsetDateTime::from_unix_timestamp(kv.1)
                                    .map_err(serde::de::Error::custom)?,
                            );
                        }
                        decoded1.insert(kv.0, decoded2);
                    }
                    decoded0.insert(kv.0, decoded1);
                }
                Ok(decoded0)
            }
            None => Ok(<HashMap<
                String,
                HashMap<String, HashMap<String, OffsetDateTime>>,
            >>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &HashMap<String, HashMap<String, HashMap<String, OffsetDateTime>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut encoded0 = <HashMap<&String, HashMap<&String, HashMap<&String, i64>>>>::new();
        for kv in to_serialize {
            let mut encoded1 = <HashMap<&String, HashMap<&String, i64>>>::new();
            for kv in kv.1 {
                let mut encoded2 = <HashMap<&String, i64>>::new();
                for kv in kv.1 {
                    encoded2.insert(kv.0, kv.1.unix_timestamp());
                }
                encoded1.insert(kv.0, encoded2);
            }
            encoded0.insert(kv.0, encoded1);
        }
        <HashMap<&String, HashMap<&String, HashMap<&String, i64>>>>::serialize(
            &encoded0, serializer,
        )
    }
}

pub mod hashmap_hashmap_offset_date_time_rfc3339 {
    #![allow(clippy::type_complexity)]
    use azure_core::date;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::collections::HashMap;
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<HashMap<String, HashMap<String, OffsetDateTime>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize =
            <Option<HashMap<String, HashMap<String, String>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <HashMap<String, HashMap<String, OffsetDateTime>>>::new();
                for kv in to_deserialize {
                    let mut decoded1 = <HashMap<String, OffsetDateTime>>::new();
                    for kv in kv.1 {
                        decoded1.insert(
                            kv.0,
                            date::parse_rfc3339(&kv.1).map_err(serde::de::Error::custom)?,
                        );
                    }
                    decoded0.insert(kv.0, decoded1);
                }
                Ok(decoded0)
            }
            None => Ok(<HashMap<String, HashMap<String, OffsetDateTime>>>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &HashMap<String, HashMap<String, OffsetDateTime>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut encoded0 = <HashMap<&String, HashMap<&String, String>>>::new();
        for kv in to_serialize {
            let mut encoded1 = <HashMap<&String, String>>::new();
            for kv in kv.1 {
                encoded1.insert(kv.0, date::to_rfc3339(kv.1));
            }
            encoded0.insert(kv.0, encoded1);
        }
        <HashMap<&String, HashMap<&String, String>>>::serialize(&encoded0, serializer)
    }
}

pub mod hashmap_hashmap_offset_date_time_rfc7231 {
    #![allow(clippy::type_complexity)]
    use azure_core::date;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::collections::HashMap;
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<HashMap<String, HashMap<String, OffsetDateTime>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize =
            <Option<HashMap<String, HashMap<String, String>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <HashMap<String, HashMap<String, OffsetDateTime>>>::new();
                for kv in to_deserialize {
                    let mut decoded1 = <HashMap<String, OffsetDateTime>>::new();
                    for kv in kv.1 {
                        decoded1.insert(
                            kv.0,
                            date::parse_rfc7231(&kv.1).map_err(serde::de::Error::custom)?,
                        );
                    }
                    decoded0.insert(kv.0, decoded1);
                }
                Ok(decoded0)
            }
            None => Ok(<HashMap<String, HashMap<String, OffsetDateTime>>>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &HashMap<String, HashMap<String, OffsetDateTime>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut encoded0 = <HashMap<&String, HashMap<&String, String>>>::new();
        for kv in to_serialize {
            let mut encoded1 = <HashMap<&String, String>>::new();
            for kv in kv.1 {
                encoded1.insert(kv.0, date::to_rfc7231(kv.1));
            }
            encoded0.insert(kv.0, encoded1);
        }
        <HashMap<&String, HashMap<&String, String>>>::serialize(&encoded0, serializer)
    }
}

pub mod hashmap_hashmap_offset_date_time_unix_time {
    #![allow(clippy::type_complexity)]
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::collections::HashMap;
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<HashMap<String, HashMap<String, OffsetDateTime>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize =
            <Option<HashMap<String, HashMap<String, i64>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <HashMap<String, HashMap<String, OffsetDateTime>>>::new();
                for kv in to_deserialize {
                    let mut decoded1 = <HashMap<String, OffsetDateTime>>::new();
                    for kv in kv.1 {
                        decoded1.insert(
                            kv.0,
                            OffsetDateTime::from_unix_timestamp(kv.1)
                                .map_err(serde::de::Error::custom)?,
                        );
                    }
                    decoded0.insert(kv.0, decoded1);
                }
                Ok(decoded0)
            }
            None => Ok(<HashMap<String, HashMap<String, OffsetDateTime>>>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &HashMap<String, HashMap<String, OffsetDateTime>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut encoded0 = <HashMap<&String, HashMap<&String, i64>>>::new();
        for kv in to_serialize {
            let mut encoded1 = <HashMap<&String, i64>>::new();
            for kv in kv.1 {
                encoded1.insert(kv.0, kv.1.unix_timestamp());
            }
            encoded0.insert(kv.0, encoded1);
        }
        <HashMap<&String, HashMap<&String, i64>>>::serialize(&encoded0, serializer)
    }
}

pub mod hashmap_offset_date_time_rfc3339 {
    #![allow(clippy::type_complexity)]
    use azure_core::date;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::collections::HashMap;
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<HashMap<String, OffsetDateTime>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<HashMap<String, String>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <HashMap<String, OffsetDateTime>>::new();
                for kv in to_deserialize {
                    decoded0.insert(
                        kv.0,
                        date::parse_rfc3339(&kv.1).map_err(serde::de::Error::custom)?,
                    );
                }
                Ok(decoded0)
            }
            None => Ok(<HashMap<String, OffsetDateTime>>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &HashMap<String, OffsetDateTime>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut encoded0 = <HashMap<&String, String>>::new();
        for kv in to_serialize {
            encoded0.insert(kv.0, date::to_rfc3339(kv.1));
        }
        <HashMap<&String, String>>::serialize(&encoded0, serializer)
    }
}

pub mod hashmap_offset_date_time_rfc7231 {
    #![allow(clippy::type_complexity)]
    use azure_core::date;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::collections::HashMap;
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<HashMap<String, OffsetDateTime>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<HashMap<String, String>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <HashMap<String, OffsetDateTime>>::new();
                for kv in to_deserialize {
                    decoded0.insert(
                        kv.0,
                        date::parse_rfc7231(&kv.1).map_err(serde::de::Error::custom)?,
                    );
                }
                Ok(decoded0)
            }
            None => Ok(<HashMap<String, OffsetDateTime>>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &HashMap<String, OffsetDateTime>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut encoded0 = <HashMap<&String, String>>::new();
        for kv in to_serialize {
            encoded0.insert(kv.0, date::to_rfc7231(kv.1));
        }
        <HashMap<&String, String>>::serialize(&encoded0, serializer)
    }
}

pub mod hashmap_offset_date_time_unix_time {
    #![allow(clippy::type_complexity)]
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::collections::HashMap;
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<HashMap<String, OffsetDateTime>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<HashMap<String, i64>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <HashMap<String, OffsetDateTime>>::new();
                for kv in to_deserialize {
                    decoded0.insert(
                        kv.0,
                        OffsetDateTime::from_unix_timestamp(kv.1)
                            .map_err(serde::de::Error::custom)?,
                    );
                }
                Ok(decoded0)
            }
            None => Ok(<HashMap<String, OffsetDateTime>>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &HashMap<String, OffsetDateTime>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut encoded0 = <HashMap<&String, i64>>::new();
        for kv in to_serialize {
            encoded0.insert(kv.0, kv.1.unix_timestamp());
        }
        <HashMap<&String, i64>>::serialize(&encoded0, serializer)
    }
}

pub mod hashmap_vec_encoded_bytes_std {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::collections::HashMap;
    use std::result::Result;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<HashMap<String, Vec<Vec<u8>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<HashMap<String, Vec<String>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <HashMap<String, Vec<Vec<u8>>>>::new();
                for kv in to_deserialize {
                    let mut decoded1 = <Vec<Vec<u8>>>::new();
                    for v in kv.1 {
                        decoded1.push(base64::decode(v).map_err(serde::de::Error::custom)?);
                    }
                    decoded0.insert(kv.0, decoded1);
                }
                Ok(decoded0)
            }
            None => Ok(<HashMap<String, Vec<Vec<u8>>>>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &HashMap<String, Vec<Vec<u8>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut encoded0 = <HashMap<&String, Vec<String>>>::new();
        for kv in to_serialize {
            encoded0.insert(kv.0, kv.1.iter().map(base64::encode).collect());
        }
        <HashMap<&String, Vec<String>>>::serialize(&encoded0, serializer)
    }
}

pub mod hashmap_vec_encoded_bytes_url {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::collections::HashMap;
    use std::result::Result;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<HashMap<String, Vec<Vec<u8>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<HashMap<String, Vec<String>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <HashMap<String, Vec<Vec<u8>>>>::new();
                for kv in to_deserialize {
                    let mut decoded1 = <Vec<Vec<u8>>>::new();
                    for v in kv.1 {
                        decoded1
                            .push(base64::decode_url_safe(v).map_err(serde::de::Error::custom)?);
                    }
                    decoded0.insert(kv.0, decoded1);
                }
                Ok(decoded0)
            }
            None => Ok(<HashMap<String, Vec<Vec<u8>>>>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &HashMap<String, Vec<Vec<u8>>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut encoded0 = <HashMap<&String, Vec<String>>>::new();
        for kv in to_serialize {
            encoded0.insert(kv.0, kv.1.iter().map(base64::encode_url_safe).collect());
        }
        <HashMap<&String, Vec<String>>>::serialize(&encoded0, serializer)
    }
}

pub mod hashmap_vec_offset_date_time_rfc7231 {
    #![allow(clippy::type_complexity)]
    use azure_core::date;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::collections::HashMap;
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<HashMap<String, Vec<OffsetDateTime>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<HashMap<String, Vec<String>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <HashMap<String, Vec<OffsetDateTime>>>::new();
                for kv in to_deserialize {
                    let mut decoded1 = <Vec<OffsetDateTime>>::new();
                    for v in kv.1 {
                        decoded1.push(date::parse_rfc7231(&v).map_err(serde::de::Error::custom)?);
                    }
                    decoded0.insert(kv.0, decoded1);
                }
                Ok(decoded0)
            }
            None => Ok(<HashMap<String, Vec<OffsetDateTime>>>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &HashMap<String, Vec<OffsetDateTime>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut encoded0 = <HashMap<&String, Vec<String>>>::new();
        for kv in to_serialize {
            encoded0.insert(kv.0, kv.1.iter().map(date::to_rfc7231).collect());
        }
        <HashMap<&String, Vec<String>>>::serialize(&encoded0, serializer)
    }
}

pub mod hashmap_vec_offset_date_time_unix_time {
    #![allow(clippy::type_complexity)]
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::collections::HashMap;
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<HashMap<String, Vec<OffsetDateTime>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<HashMap<String, Vec<i64>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <HashMap<String, Vec<OffsetDateTime>>>::new();
                for kv in to_deserialize {
                    let mut decoded1 = <Vec<OffsetDateTime>>::new();
                    for v in kv.1 {
                        decoded1.push(
                            OffsetDateTime::from_unix_timestamp(v)
                                .map_err(serde::de::Error::custom)?,
                        );
                    }
                    decoded0.insert(kv.0, decoded1);
                }
                Ok(decoded0)
            }
            None => Ok(<HashMap<String, Vec<OffsetDateTime>>>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &HashMap<String, Vec<OffsetDateTime>>,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut encoded0 = <HashMap<&String, Vec<i64>>>::new();
        for kv in to_serialize {
            encoded0.insert(kv.0, kv.1.iter().map(|v| v.unix_timestamp()).collect());
        }
        <HashMap<&String, Vec<i64>>>::serialize(&encoded0, serializer)
    }
}

pub mod vec_encoded_bytes_std {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<Vec<u8>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<String>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<Vec<u8>>>::new();
                for v in to_deserialize {
                    decoded0.push(base64::decode(v).map_err(serde::de::Error::custom)?);
                }
                Ok(decoded0)
            }
            None => Ok(<Vec<Vec<u8>>>::default()),
        }
    }

    pub fn serialize<S>(to_serialize: &[Vec<u8>], serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let encoded0 = to_serialize.iter().map(base64::encode).collect();
        <Vec<String>>::serialize(&encoded0, serializer)
    }
}

pub mod vec_encoded_bytes_url {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<Vec<u8>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<String>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<Vec<u8>>>::new();
                for v in to_deserialize {
                    decoded0.push(base64::decode_url_safe(v).map_err(serde::de::Error::custom)?);
                }
                Ok(decoded0)
            }
            None => Ok(<Vec<Vec<u8>>>::default()),
        }
    }

    pub fn serialize<S>(to_serialize: &[Vec<u8>], serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let encoded0 = to_serialize.iter().map(base64::encode_url_safe).collect();
        <Vec<String>>::serialize(&encoded0, serializer)
    }
}

pub mod vec_hashmap_vec_encoded_bytes_std {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::collections::HashMap;
    use std::result::Result;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Vec<HashMap<String, Vec<Vec<u8>>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize =
            <Option<Vec<HashMap<String, Vec<String>>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<HashMap<String, Vec<Vec<u8>>>>>::new();
                for v in to_deserialize {
                    let mut decoded1 = <HashMap<String, Vec<Vec<u8>>>>::new();
                    for kv in v {
                        let mut decoded2 = <Vec<Vec<u8>>>::new();
                        for v in kv.1 {
                            decoded2.push(base64::decode(v).map_err(serde::de::Error::custom)?);
                        }
                        decoded1.insert(kv.0, decoded2);
                    }
                    decoded0.push(decoded1);
                }
                Ok(decoded0)
            }
            None => Ok(<Vec<HashMap<String, Vec<Vec<u8>>>>>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &[HashMap<String, Vec<Vec<u8>>>],
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let encoded0 = to_serialize
            .iter()
            .map(|v| {
                let mut encoded1 = <HashMap<&String, Vec<String>>>::new();
                for kv in v {
                    encoded1.insert(kv.0, kv.1.iter().map(base64::encode).collect());
                }
                encoded1
            })
            .collect();
        <Vec<HashMap<&String, Vec<String>>>>::serialize(&encoded0, serializer)
    }
}

pub mod vec_hashmap_vec_encoded_bytes_url {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::collections::HashMap;
    use std::result::Result;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Vec<HashMap<String, Vec<Vec<u8>>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize =
            <Option<Vec<HashMap<String, Vec<String>>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<HashMap<String, Vec<Vec<u8>>>>>::new();
                for v in to_deserialize {
                    let mut decoded1 = <HashMap<String, Vec<Vec<u8>>>>::new();
                    for kv in v {
                        let mut decoded2 = <Vec<Vec<u8>>>::new();
                        for v in kv.1 {
                            decoded2.push(
                                base64::decode_url_safe(v).map_err(serde::de::Error::custom)?,
                            );
                        }
                        decoded1.insert(kv.0, decoded2);
                    }
                    decoded0.push(decoded1);
                }
                Ok(decoded0)
            }
            None => Ok(<Vec<HashMap<String, Vec<Vec<u8>>>>>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &[HashMap<String, Vec<Vec<u8>>>],
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let encoded0 = to_serialize
            .iter()
            .map(|v| {
                let mut encoded1 = <HashMap<&String, Vec<String>>>::new();
                for kv in v {
                    encoded1.insert(kv.0, kv.1.iter().map(base64::encode_url_safe).collect());
                }
                encoded1
            })
            .collect();
        <Vec<HashMap<&String, Vec<String>>>>::serialize(&encoded0, serializer)
    }
}

pub mod vec_hashmap_vec_offset_date_time_rfc3339 {
    #![allow(clippy::type_complexity)]
    use azure_core::date;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::collections::HashMap;
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Vec<HashMap<String, Vec<OffsetDateTime>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize =
            <Option<Vec<HashMap<String, Vec<String>>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<HashMap<String, Vec<OffsetDateTime>>>>::new();
                for v in to_deserialize {
                    let mut decoded1 = <HashMap<String, Vec<OffsetDateTime>>>::new();
                    for kv in v {
                        let mut decoded2 = <Vec<OffsetDateTime>>::new();
                        for v in kv.1 {
                            decoded2
                                .push(date::parse_rfc3339(&v).map_err(serde::de::Error::custom)?);
                        }
                        decoded1.insert(kv.0, decoded2);
                    }
                    decoded0.push(decoded1);
                }
                Ok(decoded0)
            }
            None => Ok(<Vec<HashMap<String, Vec<OffsetDateTime>>>>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &[HashMap<String, Vec<OffsetDateTime>>],
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let encoded0 = to_serialize
            .iter()
            .map(|v| {
                let mut encoded1 = <HashMap<&String, Vec<String>>>::new();
                for kv in v {
                    encoded1.insert(kv.0, kv.1.iter().map(date::to_rfc3339).collect());
                }
                encoded1
            })
            .collect();
        <Vec<HashMap<&String, Vec<String>>>>::serialize(&encoded0, serializer)
    }
}

pub mod vec_hashmap_vec_offset_date_time_unix_time {
    #![allow(clippy::type_complexity)]
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::collections::HashMap;
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(
        deserializer: D,
    ) -> Result<Vec<HashMap<String, Vec<OffsetDateTime>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<HashMap<String, Vec<i64>>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<HashMap<String, Vec<OffsetDateTime>>>>::new();
                for v in to_deserialize {
                    let mut decoded1 = <HashMap<String, Vec<OffsetDateTime>>>::new();
                    for kv in v {
                        let mut decoded2 = <Vec<OffsetDateTime>>::new();
                        for v in kv.1 {
                            decoded2.push(
                                OffsetDateTime::from_unix_timestamp(v)
                                    .map_err(serde::de::Error::custom)?,
                            );
                        }
                        decoded1.insert(kv.0, decoded2);
                    }
                    decoded0.push(decoded1);
                }
                Ok(decoded0)
            }
            None => Ok(<Vec<HashMap<String, Vec<OffsetDateTime>>>>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &[HashMap<String, Vec<OffsetDateTime>>],
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let encoded0 = to_serialize
            .iter()
            .map(|v| {
                let mut encoded1 = <HashMap<&String, Vec<i64>>>::new();
                for kv in v {
                    encoded1.insert(kv.0, kv.1.iter().map(|v| v.unix_timestamp()).collect());
                }
                encoded1
            })
            .collect();
        <Vec<HashMap<&String, Vec<i64>>>>::serialize(&encoded0, serializer)
    }
}

pub mod vec_offset_date_time_rfc3339 {
    #![allow(clippy::type_complexity)]
    use azure_core::date;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<OffsetDateTime>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<String>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<OffsetDateTime>>::new();
                for v in to_deserialize {
                    decoded0.push(date::parse_rfc3339(&v).map_err(serde::de::Error::custom)?);
                }
                Ok(decoded0)
            }
            None => Ok(<Vec<OffsetDateTime>>::default()),
        }
    }

    pub fn serialize<S>(to_serialize: &[OffsetDateTime], serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let encoded0 = to_serialize.iter().map(date::to_rfc3339).collect();
        <Vec<String>>::serialize(&encoded0, serializer)
    }
}

pub mod vec_offset_date_time_rfc7231 {
    #![allow(clippy::type_complexity)]
    use azure_core::date;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<OffsetDateTime>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<String>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<OffsetDateTime>>::new();
                for v in to_deserialize {
                    decoded0.push(date::parse_rfc7231(&v).map_err(serde::de::Error::custom)?);
                }
                Ok(decoded0)
            }
            None => Ok(<Vec<OffsetDateTime>>::default()),
        }
    }

    pub fn serialize<S>(to_serialize: &[OffsetDateTime], serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let encoded0 = to_serialize.iter().map(date::to_rfc7231).collect();
        <Vec<String>>::serialize(&encoded0, serializer)
    }
}

pub mod vec_offset_date_time_unix_time {
    #![allow(clippy::type_complexity)]
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<OffsetDateTime>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<i64>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<OffsetDateTime>>::new();
                for v in to_deserialize {
                    decoded0.push(
                        OffsetDateTime::from_unix_timestamp(v).map_err(serde::de::Error::custom)?,
                    );
                }
                Ok(decoded0)
            }
            None => Ok(<Vec<OffsetDateTime>>::default()),
        }
    }

    pub fn serialize<S>(to_serialize: &[OffsetDateTime], serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let encoded0 = to_serialize.iter().map(|v| v.unix_timestamp()).collect();
        <Vec<i64>>::serialize(&encoded0, serializer)
    }
}

pub mod vec_vec_encoded_bytes_std {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<Vec<Vec<u8>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<Vec<String>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<Vec<Vec<u8>>>>::new();
                for v in to_deserialize {
                    let mut decoded1 = <Vec<Vec<u8>>>::new();
                    for v in v {
                        decoded1.push(base64::decode(v).map_err(serde::de::Error::custom)?);
                    }
                    decoded0.push(decoded1);
                }
                Ok(decoded0)
            }
            None => Ok(<Vec<Vec<Vec<u8>>>>::default()),
        }
    }

    pub fn serialize<S>(to_serialize: &[Vec<Vec<u8>>], serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let encoded0 = to_serialize
            .iter()
            .map(|v| v.iter().map(base64::encode).collect())
            .collect();
        <Vec<Vec<String>>>::serialize(&encoded0, serializer)
    }
}

pub mod vec_vec_encoded_bytes_url {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<Vec<Vec<u8>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<Vec<String>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<Vec<Vec<u8>>>>::new();
                for v in to_deserialize {
                    let mut decoded1 = <Vec<Vec<u8>>>::new();
                    for v in v {
                        decoded1
                            .push(base64::decode_url_safe(v).map_err(serde::de::Error::custom)?);
                    }
                    decoded0.push(decoded1);
                }
                Ok(decoded0)
            }
            None => Ok(<Vec<Vec<Vec<u8>>>>::default()),
        }
    }

    pub fn serialize<S>(to_serialize: &[Vec<Vec<u8>>], serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let encoded0 = to_serialize
            .iter()
            .map(|v| v.iter().map(base64::encode_url_safe).collect())
            .collect();
        <Vec<Vec<String>>>::serialize(&encoded0, serializer)
    }
}

pub mod vec_vec_offset_date_time_rfc3339 {
    #![allow(clippy::type_complexity)]
    use azure_core::date;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<Vec<OffsetDateTime>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<Vec<String>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<Vec<OffsetDateTime>>>::new();
                for v in to_deserialize {
                    let mut decoded1 = <Vec<OffsetDateTime>>::new();
                    for v in v {
                        decoded1.push(date::parse_rfc3339(&v).map_err(serde::de::Error::custom)?);
                    }
                    decoded0.push(decoded1);
                }
                Ok(decoded0)
            }
            None => Ok(<Vec<Vec<OffsetDateTime>>>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &[Vec<OffsetDateTime>],
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let encoded0 = to_serialize
            .iter()
            .map(|v| v.iter().map(date::to_rfc3339).collect())
            .collect();
        <Vec<Vec<String>>>::serialize(&encoded0, serializer)
    }
}

pub mod vec_vec_offset_date_time_rfc7231 {
    #![allow(clippy::type_complexity)]
    use azure_core::date;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<Vec<OffsetDateTime>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<Vec<String>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<Vec<OffsetDateTime>>>::new();
                for v in to_deserialize {
                    let mut decoded1 = <Vec<OffsetDateTime>>::new();
                    for v in v {
                        decoded1.push(date::parse_rfc7231(&v).map_err(serde::de::Error::custom)?);
                    }
                    decoded0.push(decoded1);
                }
                Ok(decoded0)
            }
            None => Ok(<Vec<Vec<OffsetDateTime>>>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &[Vec<OffsetDateTime>],
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let encoded0 = to_serialize
            .iter()
            .map(|v| v.iter().map(date::to_rfc7231).collect())
            .collect();
        <Vec<Vec<String>>>::serialize(&encoded0, serializer)
    }
}

pub mod vec_vec_offset_date_time_unix_time {
    #![allow(clippy::type_complexity)]
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<Vec<OffsetDateTime>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<Vec<i64>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<Vec<OffsetDateTime>>>::new();
                for v in to_deserialize {
                    let mut decoded1 = <Vec<OffsetDateTime>>::new();
                    for v in v {
                        decoded1.push(
                            OffsetDateTime::from_unix_timestamp(v)
                                .map_err(serde::de::Error::custom)?,
                        );
                    }
                    decoded0.push(decoded1);
                }
                Ok(decoded0)
            }
            None => Ok(<Vec<Vec<OffsetDateTime>>>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &[Vec<OffsetDateTime>],
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let encoded0 = to_serialize
            .iter()
            .map(|v| v.iter().map(|v| v.unix_timestamp()).collect())
            .collect();
        <Vec<Vec<i64>>>::serialize(&encoded0, serializer)
    }
}

pub mod vec_vec_vec_encoded_bytes_std {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<Vec<Vec<Vec<u8>>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<Vec<Vec<String>>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<Vec<Vec<Vec<u8>>>>>::new();
                for v in to_deserialize {
                    let mut decoded1 = <Vec<Vec<Vec<u8>>>>::new();
                    for v in v {
                        let mut decoded2 = <Vec<Vec<u8>>>::new();
                        for v in v {
                            decoded2.push(base64::decode(v).map_err(serde::de::Error::custom)?);
                        }
                        decoded1.push(decoded2);
                    }
                    decoded0.push(decoded1);
                }
                Ok(decoded0)
            }
            None => Ok(<Vec<Vec<Vec<Vec<u8>>>>>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &[Vec<Vec<Vec<u8>>>],
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let encoded0 = to_serialize
            .iter()
            .map(|v| {
                v.iter()
                    .map(|v| v.iter().map(base64::encode).collect())
                    .collect()
            })
            .collect();
        <Vec<Vec<Vec<String>>>>::serialize(&encoded0, serializer)
    }
}

pub mod vec_vec_vec_encoded_bytes_url {
    #![allow(clippy::type_complexity)]
    use azure_core::base64;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<Vec<Vec<Vec<u8>>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<Vec<Vec<String>>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<Vec<Vec<Vec<u8>>>>>::new();
                for v in to_deserialize {
                    let mut decoded1 = <Vec<Vec<Vec<u8>>>>::new();
                    for v in v {
                        let mut decoded2 = <Vec<Vec<u8>>>::new();
                        for v in v {
                            decoded2.push(
                                base64::decode_url_safe(v).map_err(serde::de::Error::custom)?,
                            );
                        }
                        decoded1.push(decoded2);
                    }
                    decoded0.push(decoded1);
                }
                Ok(decoded0)
            }
            None => Ok(<Vec<Vec<Vec<Vec<u8>>>>>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &[Vec<Vec<Vec<u8>>>],
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let encoded0 = to_serialize
            .iter()
            .map(|v| {
                v.iter()
                    .map(|v| v.iter().map(base64::encode_url_safe).collect())
                    .collect()
            })
            .collect();
        <Vec<Vec<Vec<String>>>>::serialize(&encoded0, serializer)
    }
}

pub mod vec_vec_vec_offset_date_time_rfc3339 {
    #![allow(clippy::type_complexity)]
    use azure_core::date;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<Vec<Vec<OffsetDateTime>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<Vec<Vec<String>>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<Vec<Vec<OffsetDateTime>>>>::new();
                for v in to_deserialize {
                    let mut decoded1 = <Vec<Vec<OffsetDateTime>>>::new();
                    for v in v {
                        let mut decoded2 = <Vec<OffsetDateTime>>::new();
                        for v in v {
                            decoded2
                                .push(date::parse_rfc3339(&v).map_err(serde::de::Error::custom)?);
                        }
                        decoded1.push(decoded2);
                    }
                    decoded0.push(decoded1);
                }
                Ok(decoded0)
            }
            None => Ok(<Vec<Vec<Vec<OffsetDateTime>>>>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &[Vec<Vec<OffsetDateTime>>],
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let encoded0 = to_serialize
            .iter()
            .map(|v| {
                v.iter()
                    .map(|v| v.iter().map(date::to_rfc3339).collect())
                    .collect()
            })
            .collect();
        <Vec<Vec<Vec<String>>>>::serialize(&encoded0, serializer)
    }
}

pub mod vec_vec_vec_offset_date_time_rfc7231 {
    #![allow(clippy::type_complexity)]
    use azure_core::date;
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<Vec<Vec<OffsetDateTime>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<Vec<Vec<String>>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<Vec<Vec<OffsetDateTime>>>>::new();
                for v in to_deserialize {
                    let mut decoded1 = <Vec<Vec<OffsetDateTime>>>::new();
                    for v in v {
                        let mut decoded2 = <Vec<OffsetDateTime>>::new();
                        for v in v {
                            decoded2
                                .push(date::parse_rfc7231(&v).map_err(serde::de::Error::custom)?);
                        }
                        decoded1.push(decoded2);
                    }
                    decoded0.push(decoded1);
                }
                Ok(decoded0)
            }
            None => Ok(<Vec<Vec<Vec<OffsetDateTime>>>>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &[Vec<Vec<OffsetDateTime>>],
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let encoded0 = to_serialize
            .iter()
            .map(|v| {
                v.iter()
                    .map(|v| v.iter().map(date::to_rfc7231).collect())
                    .collect()
            })
            .collect();
        <Vec<Vec<Vec<String>>>>::serialize(&encoded0, serializer)
    }
}

pub mod vec_vec_vec_offset_date_time_unix_time {
    #![allow(clippy::type_complexity)]
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::result::Result;
    use time::OffsetDateTime;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<Vec<Vec<OffsetDateTime>>>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let to_deserialize = <Option<Vec<Vec<Vec<i64>>>>>::deserialize(deserializer)?;
        match to_deserialize {
            Some(to_deserialize) => {
                let mut decoded0 = <Vec<Vec<Vec<OffsetDateTime>>>>::new();
                for v in to_deserialize {
                    let mut decoded1 = <Vec<Vec<OffsetDateTime>>>::new();
                    for v in v {
                        let mut decoded2 = <Vec<OffsetDateTime>>::new();
                        for v in v {
                            decoded2.push(
                                OffsetDateTime::from_unix_timestamp(v)
                                    .map_err(serde::de::Error::custom)?,
                            );
                        }
                        decoded1.push(decoded2);
                    }
                    decoded0.push(decoded1);
                }
                Ok(decoded0)
            }
            None => Ok(<Vec<Vec<Vec<OffsetDateTime>>>>::default()),
        }
    }

    pub fn serialize<S>(
        to_serialize: &[Vec<Vec<OffsetDateTime>>],
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let encoded0 = to_serialize
            .iter()
            .map(|v| {
                v.iter()
                    .map(|v| v.iter().map(|v| v.unix_timestamp()).collect())
                    .collect()
            })
            .collect();
        <Vec<Vec<Vec<i64>>>>::serialize(&encoded0, serializer)
    }
}
