// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use crate::models::{ExtensibleShape, ExtensibleValues, FixedShape, FixedValues};
use azure_core::error::{Error, ErrorKind};
use std::{
    convert::{AsRef, From, Infallible},
    fmt::{Display, Formatter},
    str::FromStr,
};

impl<'a> From<&'a ExtensibleShape> for &'a str {
    fn from(e: &'a ExtensibleShape) -> Self {
        match e {
            ExtensibleShape::Round => "round",
            ExtensibleShape::Square => "square",
            ExtensibleShape::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for ExtensibleShape {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "round" => ExtensibleShape::Round,
            "square" => ExtensibleShape::Square,
            _ => ExtensibleShape::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for ExtensibleShape {
    fn as_ref(&self) -> &str {
        match self {
            ExtensibleShape::Round => "round",
            ExtensibleShape::Square => "square",
            ExtensibleShape::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for ExtensibleShape {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            ExtensibleShape::Round => f.write_str("round"),
            ExtensibleShape::Square => f.write_str("square"),
            ExtensibleShape::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl<'a> From<&'a ExtensibleValues> for &'a str {
    fn from(e: &'a ExtensibleValues) -> Self {
        match e {
            ExtensibleValues::One => "one",
            ExtensibleValues::Two => "two",
            ExtensibleValues::UnknownValue(s) => s.as_ref(),
        }
    }
}

impl FromStr for ExtensibleValues {
    type Err = Infallible;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "one" => ExtensibleValues::One,
            "two" => ExtensibleValues::Two,
            _ => ExtensibleValues::UnknownValue(s.to_string()),
        })
    }
}

impl AsRef<str> for ExtensibleValues {
    fn as_ref(&self) -> &str {
        match self {
            ExtensibleValues::One => "one",
            ExtensibleValues::Two => "two",
            ExtensibleValues::UnknownValue(s) => s.as_str(),
        }
    }
}

impl Display for ExtensibleValues {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            ExtensibleValues::One => f.write_str("one"),
            ExtensibleValues::Two => f.write_str("two"),
            ExtensibleValues::UnknownValue(s) => f.write_str(s.as_str()),
        }
    }
}

impl FromStr for FixedShape {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "round" => FixedShape::Round,
            "square" => FixedShape::Square,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of FixedShape found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for FixedShape {
    fn as_ref(&self) -> &str {
        match self {
            FixedShape::Round => "round",
            FixedShape::Square => "square",
        }
    }
}

impl Display for FixedShape {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            FixedShape::Round => Display::fmt("round", f),
            FixedShape::Square => Display::fmt("square", f),
        }
    }
}

impl FromStr for FixedValues {
    type Err = Error;
    fn from_str(s: &str) -> ::core::result::Result<Self, <Self as FromStr>::Err> {
        Ok(match s {
            "one" => FixedValues::One,
            "two" => FixedValues::Two,
            _ => {
                return Err(Error::with_message_fn(ErrorKind::DataConversion, || {
                    format!("unknown variant of FixedValues found: \"{s}\"")
                }))
            }
        })
    }
}

impl AsRef<str> for FixedValues {
    fn as_ref(&self) -> &str {
        match self {
            FixedValues::One => "one",
            FixedValues::Two => "two",
        }
    }
}

impl Display for FixedValues {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        match self {
            FixedValues::One => Display::fmt("one", f),
            FixedValues::Two => Display::fmt("two", f),
        }
    }
}
