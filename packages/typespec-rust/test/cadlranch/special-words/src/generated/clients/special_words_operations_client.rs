// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use azure_core::{
    AsClientMethodOptions, ClientMethodOptions, Method, Pipeline, Request, Response, Result, Url,
};

pub struct SpecialWordsOperationsClient {
    pub(crate) endpoint: Url,
    pub(crate) pipeline: Pipeline,
}

impl SpecialWordsOperationsClient {
    /// Returns the Url associated with this client.
    pub fn endpoint(&self) -> &Url {
        &self.endpoint
    }

    pub async fn and(
        &self,
        options: Option<SpecialWordsOperationsClientAndOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/and");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn as_fn(
        &self,
        options: Option<SpecialWordsOperationsClientAsOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/as");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn assert(
        &self,
        options: Option<SpecialWordsOperationsClientAssertOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/assert");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn async_fn(
        &self,
        options: Option<SpecialWordsOperationsClientAsyncOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/async");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn await_fn(
        &self,
        options: Option<SpecialWordsOperationsClientAwaitOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/await");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn break_fn(
        &self,
        options: Option<SpecialWordsOperationsClientBreakOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/break");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn class(
        &self,
        options: Option<SpecialWordsOperationsClientClassOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/class");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn constructor(
        &self,
        options: Option<SpecialWordsOperationsClientConstructorOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/constructor");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn continue_fn(
        &self,
        options: Option<SpecialWordsOperationsClientContinueOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/continue");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn def(
        &self,
        options: Option<SpecialWordsOperationsClientDefOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/def");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn del(
        &self,
        options: Option<SpecialWordsOperationsClientDelOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/del");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn elif(
        &self,
        options: Option<SpecialWordsOperationsClientElifOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/elif");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn else_fn(
        &self,
        options: Option<SpecialWordsOperationsClientElseOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/else");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn except(
        &self,
        options: Option<SpecialWordsOperationsClientExceptOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/except");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn exec(
        &self,
        options: Option<SpecialWordsOperationsClientExecOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/exec");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn finally(
        &self,
        options: Option<SpecialWordsOperationsClientFinallyOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/finally");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn for_fn(
        &self,
        options: Option<SpecialWordsOperationsClientForOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/for");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn from(
        &self,
        options: Option<SpecialWordsOperationsClientFromOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/from");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn global(
        &self,
        options: Option<SpecialWordsOperationsClientGlobalOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/global");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn if_fn(
        &self,
        options: Option<SpecialWordsOperationsClientIfOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/if");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn import(
        &self,
        options: Option<SpecialWordsOperationsClientImportOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/import");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn in_fn(
        &self,
        options: Option<SpecialWordsOperationsClientInOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/in");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn is(
        &self,
        options: Option<SpecialWordsOperationsClientIsOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/is");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn lambda(
        &self,
        options: Option<SpecialWordsOperationsClientLambdaOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/lambda");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn not(
        &self,
        options: Option<SpecialWordsOperationsClientNotOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/not");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn or(
        &self,
        options: Option<SpecialWordsOperationsClientOrOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/or");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn pass(
        &self,
        options: Option<SpecialWordsOperationsClientPassOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/pass");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn raise(
        &self,
        options: Option<SpecialWordsOperationsClientRaiseOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/raise");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn return_fn(
        &self,
        options: Option<SpecialWordsOperationsClientReturnOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/return");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn try_fn(
        &self,
        options: Option<SpecialWordsOperationsClientTryOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/try");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn while_fn(
        &self,
        options: Option<SpecialWordsOperationsClientWhileOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/while");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn with(
        &self,
        options: Option<SpecialWordsOperationsClientWithOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/with");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    pub async fn yield_fn(
        &self,
        options: Option<SpecialWordsOperationsClientYieldOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        url.set_path("/special-words/operations/yield");
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&mut ctx, &mut request).await
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientAndOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientAsOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientAssertOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientAsyncOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientAwaitOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientBreakOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientClassOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientConstructorOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientContinueOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientDefOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientDelOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientElifOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientElseOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientExceptOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientExecOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientFinallyOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientForOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientFromOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientGlobalOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientIfOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientImportOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientInOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientIsOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientLambdaOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientNotOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientOrOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientPassOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientRaiseOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientReturnOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientTryOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientWhileOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientWithOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsOperationsClientYieldOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}
