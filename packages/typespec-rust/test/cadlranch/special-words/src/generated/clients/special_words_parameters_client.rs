// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use azure_core::{ClientMethodOptions, Context, Method, Pipeline, Request, Response, Result, Url};

pub struct SpecialWordsParametersClient {
    pub(crate) endpoint: Url,
    pub(crate) pipeline: Pipeline,
}

impl SpecialWordsParametersClient {
    /// Returns the Url associated with this client.
    pub fn endpoint(&self) -> &Url {
        &self.endpoint
    }

    pub async fn with_and(
        &self,
        and: String,
        options: Option<SpecialWordsParametersClientWithAndOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/and")?;
        url.query_pairs_mut().append_pair("and", &and);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_as(
        &self,
        as_param: String,
        options: Option<SpecialWordsParametersClientWithAsOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/as")?;
        url.query_pairs_mut().append_pair("as", &as_param);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_assert(
        &self,
        assert: String,
        options: Option<SpecialWordsParametersClientWithAssertOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/assert")?;
        url.query_pairs_mut().append_pair("assert", &assert);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_async(
        &self,
        async_param: String,
        options: Option<SpecialWordsParametersClientWithAsyncOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/async")?;
        url.query_pairs_mut().append_pair("async", &async_param);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_await(
        &self,
        await_param: String,
        options: Option<SpecialWordsParametersClientWithAwaitOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/await")?;
        url.query_pairs_mut().append_pair("await", &await_param);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_break(
        &self,
        break_param: String,
        options: Option<SpecialWordsParametersClientWithBreakOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/break")?;
        url.query_pairs_mut().append_pair("break", &break_param);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_cancellation_token(
        &self,
        cancellation_token: String,
        options: Option<SpecialWordsParametersClientWithCancellationTokenOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/cancellationToken")?;
        url.query_pairs_mut()
            .append_pair("cancellationToken", &cancellation_token);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_class(
        &self,
        class: String,
        options: Option<SpecialWordsParametersClientWithClassOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/class")?;
        url.query_pairs_mut().append_pair("class", &class);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_constructor(
        &self,
        constructor: String,
        options: Option<SpecialWordsParametersClientWithConstructorOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/constructor")?;
        url.query_pairs_mut()
            .append_pair("constructor", &constructor);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_continue(
        &self,
        continue_param: String,
        options: Option<SpecialWordsParametersClientWithContinueOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/continue")?;
        url.query_pairs_mut()
            .append_pair("continue", &continue_param);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_def(
        &self,
        def: String,
        options: Option<SpecialWordsParametersClientWithDefOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/def")?;
        url.query_pairs_mut().append_pair("def", &def);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_del(
        &self,
        del: String,
        options: Option<SpecialWordsParametersClientWithDelOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/del")?;
        url.query_pairs_mut().append_pair("del", &del);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_elif(
        &self,
        elif: String,
        options: Option<SpecialWordsParametersClientWithElifOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/elif")?;
        url.query_pairs_mut().append_pair("elif", &elif);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_else(
        &self,
        else_param: String,
        options: Option<SpecialWordsParametersClientWithElseOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/else")?;
        url.query_pairs_mut().append_pair("else", &else_param);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_except(
        &self,
        except: String,
        options: Option<SpecialWordsParametersClientWithExceptOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/except")?;
        url.query_pairs_mut().append_pair("except", &except);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_exec(
        &self,
        exec: String,
        options: Option<SpecialWordsParametersClientWithExecOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/exec")?;
        url.query_pairs_mut().append_pair("exec", &exec);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_finally(
        &self,
        finally: String,
        options: Option<SpecialWordsParametersClientWithFinallyOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/finally")?;
        url.query_pairs_mut().append_pair("finally", &finally);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_for(
        &self,
        for_param: String,
        options: Option<SpecialWordsParametersClientWithForOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/for")?;
        url.query_pairs_mut().append_pair("for", &for_param);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_from(
        &self,
        from: String,
        options: Option<SpecialWordsParametersClientWithFromOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/from")?;
        url.query_pairs_mut().append_pair("from", &from);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_global(
        &self,
        global: String,
        options: Option<SpecialWordsParametersClientWithGlobalOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/global")?;
        url.query_pairs_mut().append_pair("global", &global);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_if(
        &self,
        if_param: String,
        options: Option<SpecialWordsParametersClientWithIfOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/if")?;
        url.query_pairs_mut().append_pair("if", &if_param);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_import(
        &self,
        import: String,
        options: Option<SpecialWordsParametersClientWithImportOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/import")?;
        url.query_pairs_mut().append_pair("import", &import);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_in(
        &self,
        in_param: String,
        options: Option<SpecialWordsParametersClientWithInOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/in")?;
        url.query_pairs_mut().append_pair("in", &in_param);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_is(
        &self,
        is: String,
        options: Option<SpecialWordsParametersClientWithIsOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/is")?;
        url.query_pairs_mut().append_pair("is", &is);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_lambda(
        &self,
        lambda: String,
        options: Option<SpecialWordsParametersClientWithLambdaOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/lambda")?;
        url.query_pairs_mut().append_pair("lambda", &lambda);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_not(
        &self,
        not: String,
        options: Option<SpecialWordsParametersClientWithNotOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/not")?;
        url.query_pairs_mut().append_pair("not", &not);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_or(
        &self,
        or: String,
        options: Option<SpecialWordsParametersClientWithOrOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/or")?;
        url.query_pairs_mut().append_pair("or", &or);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_pass(
        &self,
        pass: String,
        options: Option<SpecialWordsParametersClientWithPassOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/pass")?;
        url.query_pairs_mut().append_pair("pass", &pass);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_raise(
        &self,
        raise: String,
        options: Option<SpecialWordsParametersClientWithRaiseOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/raise")?;
        url.query_pairs_mut().append_pair("raise", &raise);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_return(
        &self,
        return_param: String,
        options: Option<SpecialWordsParametersClientWithReturnOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/return")?;
        url.query_pairs_mut().append_pair("return", &return_param);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_try(
        &self,
        try_param: String,
        options: Option<SpecialWordsParametersClientWithTryOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/try")?;
        url.query_pairs_mut().append_pair("try", &try_param);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_while(
        &self,
        while_param: String,
        options: Option<SpecialWordsParametersClientWithWhileOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/while")?;
        url.query_pairs_mut().append_pair("while", &while_param);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_with(
        &self,
        with: String,
        options: Option<SpecialWordsParametersClientWithOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/with")?;
        url.query_pairs_mut().append_pair("with", &with);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }

    pub async fn with_yield(
        &self,
        yield_param: String,
        options: Option<SpecialWordsParametersClientWithYieldOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let ctx = Context::with_context(&options.method_options.context);
        let mut url = self.endpoint.clone();
        url = url.join("special-words/parameters/yield")?;
        url.query_pairs_mut().append_pair("yield", &yield_param);
        let mut request = Request::new(url, Method::Get);
        self.pipeline.send(&ctx, &mut request).await
    }
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithAndOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithAsOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithAssertOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithAsyncOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithAwaitOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithBreakOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithCancellationTokenOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithClassOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithConstructorOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithContinueOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithDefOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithDelOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithElifOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithElseOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithExceptOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithExecOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithFinallyOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithForOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithFromOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithGlobalOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithIfOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithImportOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithInOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithIsOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithLambdaOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithNotOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithOrOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithPassOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithRaiseOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithReturnOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithTryOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithWhileOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecialWordsParametersClientWithYieldOptions<'a> {
    pub method_options: ClientMethodOptions<'a>,
}
