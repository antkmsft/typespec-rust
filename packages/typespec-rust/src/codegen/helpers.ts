/*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/

import { CodegenError } from './errors.js';
import { Use } from './use.js';
import * as rust from '../codemodel/index.js';
import * as shared from '../shared/shared.js';

const headerText = `// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator.`;

export const AnnotationNonExhaustive = '#[non_exhaustive]\n';

export const AnonymousLifetimeAnnotation = '<\'_>';

/** defines the possible visibilities for a module */
export type ModuleVisibility = 'internal' | 'pubUse' | 'pubCrate';

/** a module to emit */
export interface Module {
  /** the name of the module */
  readonly name: string;

  /** the contents of the module */
  readonly content: string;

  /** the visibility of the module */
  readonly visibility: ModuleVisibility;
}

/** used to track the visibility of types within a module */
export class VisibilityTracker {
  private visibility: ModuleVisibility;
  constructor() {
    // default to pub(crate). if at least one item
    // is pub then we'll flip this to pubUse
    this.visibility = 'pubCrate';
  }

  /**
   * gets the module visibility status.
   * this should be called after update()
   * has been called for all items.
   * 
   * @returns the module visibility
   */
  get(): ModuleVisibility {
    return this.visibility;
  }

  /**
   * updates the state of the visibility tracker.
   * 
   * @param visibility the visibility of an item
   */
  update(visibility: rust.Visibility): void {
    if (visibility === 'pub') {
      this.visibility = 'pubUse';
    }
  }
}

/**
 * returns the content preamble common to all emitted files
 * 
 * @param [includeDNE=true] controls if the phrase 'DO NOT EDIT' should be included
 * @returns the preamble content
 */
export function contentPreamble(includeDNE: boolean = true): string {
  return `${headerText}${includeDNE ? ' DO NOT EDIT.' : ''}\n\n`;
}

/**
 * formats doc comments if available
 * 
 * @param docs contains any doc comments
 * @param forDocAttr indicates doc comments will be in a #[doc] attribute, thus omitting the /// prefixes (defaults to false)
 * @param prefix optional prefix to insert before the docs
 * @param indent optional indentation helper to set per-line indentation
 * @returns formatted doc comments or the empty string
 */
export function formatDocComment(docs: rust.Docs, forDocAttr = false, prefix?: string, indent?: indentation): string {
  if (!docs.summary && !docs.description) {
    return '';
  }

  let indentLevel = '';
  if (indent) {
    indentLevel = indent.get();
  }

  const commentLines = function(docs: string): string {
    let commentedLines = '';
    const lines = docs.split('\n');
    for (const line of lines) {
      if ((line === '' || line.match(/^\s+$/)) && !forDocAttr) {
        // "something something\n\nsomething else" becomes:
        // /// something something
        // ///
        // /// something else
        commentedLines += `${indentLevel}///\n`;
        continue;
      }

      // first create the comment block. note that it can be multi-line depending on length:
      //
      // * foo - some comment first line
      // and it finishes here.
      let formattedLine = shared.comment(line.trim(), `${indentLevel}/// `, undefined, 120);

      // transform the above to look like this:
      //
      // * foo - some comment first line
      //   and it finishes here.
      const blockStartMatch = formattedLine.match(/^\/\/\/\s+([*-]|(?:\d+\.))/);
      if (blockStartMatch && formattedLine.split('\n').length > 1) {
        const chunks = formattedLine.split('\n');
        for (let i = 1; i < chunks.length; ++i) {
          // indent size is based on the size of the captured starting block minus 3 for the /// chars
          chunks[i] = chunks[i].replace('/// ', `/// ${' '.repeat(blockStartMatch[0].length - 3)}`);
        }
        formattedLine = chunks.join('\n');
      }
      commentedLines += formattedLine + '\n';
    }

    if (forDocAttr) {
      // #[doc] are the uncommon case, so just remove the ///
      // instead of trying to be clever when forming the comment block.
      commentedLines = commentedLines.replace(new RegExp('/// ', 'g'), '');
    }
    return commentedLines;
  };

  let docStr = '';
  if (docs.summary) {
    let summary = docs.summary;
    if (prefix) {
      summary = `${prefix}${summary}`;
    }
    docStr = commentLines(summary);
  }

  if (docs.description) {
    let description = docs.description;
    if (docs.summary) {
      docStr += `${indentLevel}///\n`;
    } else if (prefix) {
      // only apply the prefix to the description if there was no summary
      description = `${prefix}${description}`;
    }
    docStr += commentLines(description);
  }

  return docStr;
}

/**
 * returns the specified visibility prefix
 * 
 * @param visibility the visibility to evaluate
 * @returns the prefix
 */
export function emitVisibility(visibility: rust.Visibility): string {
  switch (visibility) {
    case 'pub':
      return 'pub ';
    case 'pubCrate':
      return 'pub(crate) ';
  }
}

/**
 * returns the type declaration string for the specified Rust type
 * 
 * @param type is the Rust type for which to emit the declaration
 * @param withLifetime controls how the lifetime annotation is emitted:
 *   - 'default': Emits the standard lifetime annotation if required by the type.
 *   - 'anonymous': Emits an anonymous lifetime annotation (e.g., <'_>) if required by the type.
 *   - 'omit': Omits the lifetime annotation entirely, even if the type would normally require one.
 * @returns 
 */
export function getTypeDeclaration(type: rust.Client | rust.Payload | rust.ResponseHeadersTrait | rust.Type, withLifetime: 'default' | 'anonymous' | 'omit' = 'default'): string {
  switch (type.kind) {
    case 'arc':
      return `${type.name}<dyn ${getTypeDeclaration(type.type)}>`;
    case 'asyncResponse':
      if (type.type.kind === 'unit') {
        // unit is the default so we can elide it
        return type.name;
      }
      return `${type.name}<${getTypeDeclaration(type.type)}>`;
    case 'box':
      return `Box<${getTypeDeclaration(type.type)}>`;
    case 'bytes':
    case 'client':
    case 'decimal':
    case 'marker':
      return type.name;
    case 'clientMethodOptions':
    case 'pollerOptions':
      return `${type.name}${getGenericLifetimeAnnotation(type.lifetime)}`;
    case 'encodedBytes':
      return type.slice ? '[u8]' : 'Vec<u8>';
    case 'enumValue':
      return `${type.type.name}`;
    case 'Etag':
      return type.kind;
    case 'hashmap':
      return `${type.name}<String, ${getTypeDeclaration(type.type, withLifetime)}>`;
    case 'implTrait':
      return `impl ${type.name}<${getTypeDeclaration(type.type, withLifetime)}>`;
    case 'literal':
      return getTypeDeclaration(type.valueKind);
    case 'option':
      return `Option<${getTypeDeclaration(type.type, withLifetime)}>`;
    case 'pager': {
      let formatParam = '';
      let continuationParam = '';
      // we need a third generic type param when the continuation isn't a next link
      if (type.continuation !== 'nextLink') {
        formatParam = `, ${type.type.format}`;
        continuationParam = ', String';
      } else if (type.type.format !== 'JsonFormat') {
        formatParam =  `, ${type.type.format}`;
      }
      // we explicitly omit the Response<T> from the type decl
      return `Pager<${getTypeDeclaration(type.type.content, withLifetime)}${formatParam}${continuationParam}>`;
    }
    case 'pagerOptions':
      // for continuation tokens we need an extra generic type parameter
      return `${type.name}<${type.lifetime.name}${type.continuation === 'nextLink' ? '' : ', String'}>`;
    case 'poller':
      // we explicitly omit the Response<T> from the type decl
      return `Poller<${getTypeDeclaration(type.type.content, withLifetime)}>`;
    case 'payload':
      return getTypeDeclaration(type.type, withLifetime);
    case 'ref':
      return `&${getTypeDeclaration(type.type)}`;
    case 'requestContent': {
      const formatType = `${type.format !== 'JsonFormat' ? `, ${type.format}` : ''}`;
      switch (type.content.kind) {
        case 'bytes':
          return `${type.name}<${getTypeDeclaration(type.content)}${formatType}>`;
        case 'payload':
          return `${type.name}<${getTypeDeclaration(type.content.type, withLifetime)}${formatType}>`;
      }
      break;
    }
    case 'result':
      return `${type.name}<${getTypeDeclaration(type.type, withLifetime)}>`;
    case 'response':
      // JsonFormat is the default, so we can elide it
      return `${type.name}<${getTypeDeclaration(type.content)}${type.format !== 'JsonFormat' ? `, ${type.format}` : ''}>`;
    case 'String':
    case 'Url':
    case 'str':
      return type.kind;
    case 'scalar':
      return type.type;
    case 'slice':
      return `[${getTypeDeclaration(type.type)}]`;
    case 'discriminatedUnion':
    case 'enum':
    case 'jsonValue':
    case 'offsetDateTime':
    case 'rawResponse':
    case 'responseHeadersTrait':
    case 'safeint':
    case 'tokenCredential':
      return type.name;
    case 'external':
    case 'model':
    case 'struct':
      if (!type.lifetime) {
        return type.name;
      }
      switch (withLifetime) {
        case 'default':
          return `${type.name}${getGenericLifetimeAnnotation(type.lifetime)}`;
        case 'anonymous':
          return `${type.name}${AnonymousLifetimeAnnotation}`;
        default:
          return type.name;
      }
    case 'unit':
      return '()';      
    case 'Vec':
      return `${type.kind}<${getTypeDeclaration(type.type, withLifetime)}>`;
  }
}

// four spaces per indent level
const oneIndentation = '    ';

/** helper for managing indentation levels */
export class indentation {
  private level: number;
  constructor(level?: number) {
    if (level !== undefined) {
      this.level = level;
    } else {
      // default to one level of indentation
      this.level = 1;
    }
  }

  /**
   * returns spaces for the current indentation level
   * 
   * @returns a string with the current indentation level
   */
  get(): string {
    let indent = '';
    for (let i = 0; i < this.level; ++i) {
      indent += oneIndentation;
    }
    return indent;
  }

  /**
   * increments the indentation level
   * 
   * @returns this indentation instance
   */
  push(): indentation {
    ++this.level;
    return this;
  }

  /**
   * decrements the indentation level
   * 
   * @returns this indentation instance
   */
  pop(): indentation {
    --this.level;
    if (this.level < 0) {
      throw new CodegenError('InternalError', 'indentation stack underflow');
    }
    return this;
  }
}

/**
 * emits the derive annotation with the standard and any additional values
 * 
 * @param serde indicates if serde annotations should be included
 * @param extra contains any extra derive values
 * @returns a derive macro
 */
export function annotationDerive(serde: boolean, ...extra: Array<string>): string {
  const derive = new Array<string>('Clone', 'SafeDebug');
  if (serde) {
    derive.push('Deserialize', 'Serialize');
  }
  // remove any empty values
  extra = extra.filter(entry => entry.trim() !== '');
  derive.push(...extra);
  derive.sort();
  return `#[derive(${derive.join(', ')})]\n`;
}

/**
 * used to sort strings in ascending order
 * 
 * @param a is the value on the left side
 * @param b is the value on the right side
 * @returns -1 if a < b, 1 if a > b, or 0 if they're equal
 */
export function sortAscending(a: string, b: string): number {
  return a < b ? -1 : a > b ? 1 : 0;
}

/**
 * returns the generic lifetime annotation string for lifetime (e.g. <'a>)
 * 
 * @param lifetime contains the Rust lifetime value
 * @returns the properly formatted lifetime annotation
 */
export function getGenericLifetimeAnnotation(lifetime: rust.Lifetime): string {
  return `<${lifetime.name}>`;
}

/**
 * construct a for in block
 * 
 * @param indent the current indentation helper in scope
 * @param loopVar the loop var(s) for each iteration
 * @param iterator the content to iterate
 * @param body the body of the for in block
 * @returns the text for the for in block
 */
export function buildForIn(indent: indentation, loopVar: string, iterator: string, body: (indent: indentation) => string): string {
  let forIn = `for ${loopVar} in ${iterator} {\n`;
  forIn += body(indent.push());
  forIn += `${indent.pop().get()}}\n`;
  return forIn;
}

/** the if condition in an if block */
export interface ifBlock {
  /** the condition in the if block */
  condition: string;

  /** the body of the if block */
  body: (indent: indentation) => string;
}

/** the else condition in an if/else block */
export interface elseBlock {
  /** the body of the else block */
  body: (indent: indentation) => string;
}

/**
 * constructs an if block
 * 
 * @param indent the current indentation helper in scope
 * @param ifBlock the if block definition
 * @param elseBlock optional else block definition
 * @returns the text for the if block
 */
export function buildIfBlock(indent: indentation, ifBlock: ifBlock, elseBlock?: elseBlock): string {
  let body = `if ${ifBlock.condition} {\n`;
  body += ifBlock.body(indent.push());
  body += `${indent.pop().get()}}`;

  if (elseBlock) {
    body += ' else {\n';
    body += elseBlock.body(indent.push());
    body += `${indent.pop().get()}}`;
  }

  return body;
}

/** an arm in a match expression */
export interface matchArm {
  /** the pattern being matched */
  pattern: string;

  /** optional return type for this match arm */
  returns?: string;

  /** the body of this match arm */
  body: (indent: indentation) => string;
}

/**
 * constructs a match expression
 * 
 * @param indent the current indentation helper in scope
 * @param expr the expression to match
 * @param arms one or more match arms
 * @returns the text for the match block
 */
export function buildMatch(indent: indentation, expr: string, arms: Array<matchArm>): string {
  let match = `match ${expr} {\n`;
  indent.push();
  for (const arm of arms) {
    match += `${indent.get()}${arm.pattern} => ${arm.returns ? arm.returns + ' ' : ''}{\n`;
    match += arm.body(indent.push());
    // the comma after an arm block is optional depending on the number
    // of lines in the block. we'll always emit it and rely on cargo fmt
    // to remove it as required.
    match += `${indent.pop().get()}},\n`;
  }
  match += `${indent.pop().get()}}`;
  return match;
}

/**
 * constructs a while loop
 * 
 * @param indent the current indentation helper in scope
 * @param condition the condition for the while loop
 * @param body the body of the while loop
 * @returns the text for the while loop
 */
export function buildWhile(indent: indentation, condition: string, body: (indent: indentation) => string): string {
  let whileLoop = `while ${condition} {\n`;
  whileLoop += body(indent.push());
  whileLoop += `${indent.pop().get()}}\n`;
  return whileLoop;
}

/**
 * returns capitalized str
 * e.g. foo -> Foo
 * 
 * @param str the string to capitalize
 * @returns the capitalized value
 */
export function capitalize(str: string): string {
  return shared.capitalize(str);
}

/**
 * recursively unwraps a type. if type is an Option<Vec<T>>, returns the T
 * 
 * @param type is the type to unwrap
 * @returns the wrapped type or the original type if it wasn't wrapped
 */
export function unwrapType(type: rust.Payload | rust.Type): rust.Type {
  switch (type.kind) {
    case 'arc':
    case 'hashmap':
    case 'option':
    case 'ref':
    case 'slice':
    case 'Vec':
      return unwrapType(type.type);
    case 'pager':
      return unwrapType(type.type.content);
    case 'poller':
      return unwrapType(type.type.content);
    case 'payload':
      return unwrapType(type.type);
    default:
      return type;
  }
}

/** the wire format used */
export type ModelFormat = 'json' | 'xml';

/**
 * converts a ResponseFormat to json or xml
 * 
 * @param format is the format to convert
 * @returns json or xml
 */
export function convertResponseFormat(format: Exclude<rust.PayloadFormatType, 'NoFormat'>): ModelFormat {
  switch (format) {
    case 'JsonFormat':
      return 'json';
    case 'XmlFormat':
      return 'xml';
  }
}

/**
 * returns the applicable base64 decoding/encoding function and brings it into scope
 * 
 * @param encoding the type of encoding
 * @param direction if the payload is being decoded or encoded
 * @param use the use statement builder currently in scope
 * @returns the base64 decode/encode method
 */
export function getBytesEncodingMethod(encoding: rust.BytesEncoding, direction: 'decode' | 'encode', use: Use): string {
  let method: string;
  switch (encoding) {
    case 'std':
      method = direction;
      break;
    case 'url':
      method = `${direction}_url_safe`;
      break;
  }
  use.add('azure_core', 'base64');
  return `base64::${method}`;
}

/**
 * returns the applicable OffsetDateTime parse/to helper and brings it into scope.
 * note that for unix_time, the 'to' direction returns a method on the OffsetDateTime type.
 * 
 * @param encoding the type of encoding
 * @param direction if the value is being parsed or converted to another format
 * @param use the use statement builder currently in scope
 * @returns the helper function or method
 */
export function getDateTimeEncodingMethod(encoding: rust.DateTimeEncoding, direction: 'parse' | 'to', use: Use): string {
  if (encoding === 'unix_time') {
    switch (direction) {
      case 'parse':
        return 'OffsetDateTime::from_unix_timestamp';
      case 'to':
        return 'unix_timestamp()';
    }
  }

  const method = `${direction}_${encoding}`;
  use.add('azure_core', `time::${method}`);
  return method;
}

/**
 * wraps the specified string in back tick characters.
 * e.g. `value`
 * 
 * @param value the string to wrap
 * @returns the string wrapped in back ticks
 */
export function wrapInBackTicks(value: string): string {
  return `\`${value}\``;
}

/**
 * emits a sequence of back tick characters
 * 
 * @param count the number of back ticks to emit
 * @returns a string of back tick characters
 */
export function emitBackTicks(count: number): string {
  let backticks = '';
  for (let i = 0; i < count; ++i) {
    backticks += '`';
  }
  return backticks;
}

/**
 * returns a variable name that's unique with respect to the provided parameters.
 * the candidates are selected in ascending order. if all candidates collide then
 * the last candidate is selected and a number appended to the end (e.g. candidate_N).
 * 
 * @param params the parameters in the method
 * @param candidates the candidate names in ascending order
 * @returns one of candidates or the last candidate with a suffix
 */
export function getUniqueVarName(params: Array<rust.MethodParameter>, candidates: Array<string>): string {
  let i = 0;
  while (true) {
    // if all the candidates have been exhausted
    // then append the count to the last one.
    // we subtract the length to start at zero.
    const candidate = i < candidates.length ? candidates[i] : `${candidates[candidates.length - 1]}_${i - candidates.length}`;

    let collides = false;
    for (const param of params) {
      // we include optional params since we will "if let Some(param.name)" them
      if (param.name === candidate) {
        collides = true;
        break;
      }
    }

    if (!collides) {
      return candidate;
    }

    ++i;
  }
}

/** narrows param to the applicable path parameter type within the conditional block */
export function isPathParameter(param: rust.MethodParameter): param is rust.PathCollectionParameter | rust.PathHashMapParameter | rust.PathScalarParameter {
  switch (param.kind) {
    case 'pathCollection':
    case 'pathHashMap':
    case 'pathScalar':
      return true;
    default:
      return false;
  }
}

/** narrows param to the applicable query parameter type within the conditional block */
export function isQueryParameter(param: rust.MethodParameter): param is rust.QueryCollectionParameter | rust.QueryHashMapParameter | rust.QueryScalarParameter {
  switch (param.kind) {
    case 'queryCollection':
    case 'queryHashMap':
    case 'queryScalar':
      return true;
    default:
      return false;
  }
}
