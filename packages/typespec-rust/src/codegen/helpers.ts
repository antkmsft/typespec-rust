/*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/

import * as codegen from '@azure-tools/codegen';
import * as rust from '../codemodel/index.js';

const headerText = `// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

`;

export const AnnotationNonExhaustive = '#[non_exhaustive]\n';

export const AnonymousLifetimeAnnotation = '<\'_>';

/**
 * returns the content preamble common to all emitted files
 * 
 * @returns the preamble content
 */
export function contentPreamble(): string {
  return headerText;
}

/**
 * formats doc comments if available
 * 
 * @param docs contains any doc comments
 * @returns formatted doc comments or the empty string
 */
export function formatDocComment(docs: rust.Docs): string {
  if (!docs.summary && !docs.description) {
    return '';
  }

  let docStr = '';
  if (docs.summary) {
    docStr = codegen.comment(docs.summary, '/// ', undefined, 120) + '\n';
  }

  if (docs.description) {
    if (docs.summary) {
      docStr += '///\n';
    }
    docStr += codegen.comment(docs.description, '/// ', undefined, 120) + '\n';
  }

  return docStr;
}

/**
 * returns 'pub ' prefix as required
 * 
 * @param pub true if the prefix is required
 * @returns the prefix or the empty string
 */
export function emitPub(pub: boolean): string {
  return pub ? 'pub ' : '';
}

/**
 * returns the type declaration string for the specified Rust type
 * 
 * @param type is the Rust type for which to emit the declaration
 * @param withAnonymousLifetime indicates if an existing lifetime annotation should be substituted with the anonymous lifetime
 * @returns 
 */
export function getTypeDeclaration(type: rust.Client | rust.Type, withAnonymousLifetime = false): string {
  switch (type.kind) {
    case 'arc':
      return `${type.name}<dyn ${getTypeDeclaration(type.type)}>`;
    case 'bytes':
    case 'client':
      return type.name;
    case 'encodedBytes':
      return 'Vec<u8>';
    case 'Etag':
      return type.kind;
    case 'hashmap':
      return `${type.name}<String, ${getTypeDeclaration(type.type, withAnonymousLifetime)}>`;
    case 'implTrait':
      return `impl ${type.name}<${getTypeDeclaration(type.type, withAnonymousLifetime)}>`;
    case 'literal':
      return `${type.value}`;
    case 'option':
      return `Option<${getTypeDeclaration(type.type, withAnonymousLifetime)}>`;
    case 'pager':
      return `Pager<${getTypeDeclaration(type.type, withAnonymousLifetime)}>`;
    case 'requestContent':
      switch (type.content.kind) {
        case 'bytes':
          return `${type.name}<${getTypeDeclaration(type.content)}>`;
        case 'payload':
          return `${type.name}<${getTypeDeclaration(type.content.type, withAnonymousLifetime)}>`;
      }
      break;
    case 'result':
      return `${type.name}<${getTypeDeclaration(type.type, withAnonymousLifetime)}>`;
    case 'response':
      switch (type.content.kind) {
        case 'payload':
          return `${type.name}<${getTypeDeclaration(type.content.type, withAnonymousLifetime)}>`;
        case 'responseBody':
          // for Response<T>, T defaults to ResponseBody so we can elide it
          return type.name;
        case 'unit':
          return `${type.name}<${getTypeDeclaration(type.content)}>`;
      }
      break;
    case 'String':
    case 'str':
    case 'Url':
      return type.kind;
    case 'scalar':
      return type.type;
    case 'enum':
    case 'jsonValue':
    case 'offsetDateTime':
    case 'tokenCredential':
      return type.name;
    case 'external':
    case 'model':
    case 'struct':
      if (!type.lifetime) {
        return type.name;
      } else if (withAnonymousLifetime) {
        // this type has a lifetime but we don't want its name
        return `${type.name}${AnonymousLifetimeAnnotation}`;
      }
      return `${type.name}${getGenericLifetimeAnnotation(type.lifetime)}`;
    case 'unit':
      return '()';      
    case 'vector':
      return `Vec<${getTypeDeclaration(type.type, withAnonymousLifetime)}>`;
  }
}

// four spaces per indent level
const oneIndentation = '    ';

/** helper for managing indentation levels */
export class indentation {
  private level: number;
  constructor(level?: number) {
    if (level !== undefined) {
      this.level = level;
    } else {
      // default to one level of indentation
      this.level = 1;
    }
  }

  /**
   * returns spaces for the current indentation level
   * 
   * @returns a string with the current indentation level
   */
  get(): string {
    let indent = '';
    for (let i = 0; i < this.level; ++i) {
      indent += oneIndentation;
    }
    return indent;
  }

  /**
   * increments the indentation level
   * 
   * @returns this indentation instance
   */
  push(): indentation {
    ++this.level;
    return this;
  }

  /**
   * decrements the indentation level
   * 
   * @returns this indentation instance
   */
  pop(): indentation {
    --this.level;
    if (this.level < 0) {
      throw new Error('indentation stack underflow');
    }
    return this;
  }
}

/**
 * emits the derive annotation with the standard and any additional values
 * 
 * @param extra contains any extra derive values
 * @returns a derive macro
 */
export function annotationDerive(...extra: Array<string>): string {
  const derive = new Array<string>('Clone', 'Deserialize', 'SafeDebug', 'Serialize');
  // remove any empty values
  extra = extra.filter(entry => entry.trim() !== '');
  derive.push(...extra);
  derive.sort();
  return `#[derive(${derive.join(', ')})]\n`;
}

/**
 * used to sort strings in ascending order
 * 
 * @param a is the value on the left side
 * @param b is the value on the right side
 * @returns -1 if a < b, 1 if a > b, or 0 if they're equal
 */
export function sortAscending(a: string, b: string): number {
  return a < b ? -1 : a > b ? 1 : 0;
}

/**
 * returns the generic lifetime annotation string for lifetime (e.g. <'a>)
 * 
 * @param lifetime contains the Rust lifetime value
 * @returns the properly formatted lifetime annotation
 */
export function getGenericLifetimeAnnotation(lifetime: rust.Lifetime): string {
  return `<${lifetime.name}>`;
}

/** the if condition in an if block */
export interface ifBlock {
  /** the condition in the if block */
  condition: string;

  /** the body of the if block */
  body: (indent: indentation) => string;
}

/**
 * constructs an if block (can expand to include else if/else as necessary)
 * 
 * @param indent the current indentation helper in scope
 * @param ifBlock the if block definition
 * @returns the text for the if block
 */
export function buildIfBlock(indent: indentation, ifBlock: ifBlock): string {
  let body = `if ${ifBlock.condition} {\n`;
  body += ifBlock.body(indent.push());
  body += `${indent.pop().get()}}`;
  return body;
}

/** an arm in a match expression */
export interface matchArm {
  /** the pattern being matched */
  pattern: string;

  /** optional return type for this match arm */
  returns?: string;

  /** the body of this match arm */
  body: (indent: indentation) => string;
}

/**
 * constructs a match expression at the provided indentation level
 * 
 * @param indent the current indentation helper in scope
 * @param expr the expression to match
 * @param arms one or more match arms
 * @returns the text for the match block
 */
export function buildMatch(indent: indentation, expr: string, arms: Array<matchArm>): string {
  let match = `match ${expr} {\n`;
  indent.push();
  for (const arm of arms) {
    match += `${indent.get()}${arm.pattern} => ${arm.returns ? arm.returns + ' ' : ''}{\n`;
    match += arm.body(indent.push());
    // the comma after an arm block is optional depending on the number
    // of lines in the block. we'll always emit it and rely on cargo fmt
    // to remove it as required.
    match += `${indent.pop().get()}},\n`;
  }
  match += `${indent.pop().get()}}`;
  return match;
}

/**
 * returns capitalized str
 * e.g. foo -> Foo
 * 
 * @param str the string to capitalize
 * @returns the capitalized value
 */
export function capitalize(str: string): string {
  return codegen.capitalize(str);
}

/**
 * if type is an Option<T>, returns the T, else returns type
 * 
 * @param type is the type to unwrap
 * @returns the wrapped type or the original type if it wasn't wrapped
 */
export function unwrapOption(type: rust.Type): rust.Type {
  if (type.kind === 'option') {
    return type.type;
  }
  return type;
}

/**
 * recursively unwraps a type. if type is an Option<Vec<T>>, returns the T
 * 
 * @param type is the type to unwrap
 * @returns the wrapped type or the original type if it wasn't wrapped
 */
export function unwrapType(type: rust.Type): rust.Type {
  switch (type.kind) {
    case 'arc':
    case 'option':
    case 'hashmap':
    case 'vector':
      return unwrapType(type.type);
    default:
      return type;
  }
}
