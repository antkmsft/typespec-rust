/*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/

import * as codegen from '@azure-tools/codegen';
import * as rust from '../codemodel/index.js';

const headerText = `// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

`;

export const AnnotationNonExhaustive = '#[non_exhaustive]\n';

export const UseSerDe = 'use serde::{Deserialize, Serialize};\n';

// returns the content preamble common to all emitted files
export function contentPreamble(): string {
  return headerText;
}

// formats doc comments if available
export function formatDocComment(docs?: string): string {
  if (!docs) {
    return '';
  }
  return codegen.comment(docs, '/// ', undefined, 120) + '\n';
}

// returns 'pub ' prefix as required
export function emitPub(pub: boolean): string {
  return pub ? 'pub ' : '';
}

// returns the type declaration string for the specified Rust type
export function getTypeDeclaration(type: rust.Type): string {
  switch (type.kind) {
    case 'empty':
      return '()';
    case 'external':
      return type.name;
    case 'generic': {
      const typeParams = new Array<string>();
      for (const typep of type.types) {
        typeParams.push(getTypeDeclaration(typep));
      }
      return `${type.name}<${typeParams.join(', ')}>`;
    }
    case 'implTrait':
      return `impl ${type.name}<${getTypeDeclaration(type.type)}>`;
    case 'literal':
      return `${type.value}`;
    case 'option':
      return `Option<${type.ref ? '&' : ''}${getTypeDeclaration(type.type)}>`;
    case 'requestContet':
      return `RequestContent<${getTypeDeclaration(type.type)}>`;
    case 'String':
    case 'str':
      return type.kind;
    case 'scalar':
      return type.type;
    case 'enum':
    case 'model':
    case 'struct':
      return type.name;
  }
}

// four spaces per indent level
const oneIndentation = '    ';

// helper for managing indentation levels
export class indentation {
  private level: number;
  constructor() {
    // level is one-based.
    this.level = 1;
  }

  // returns spaces for the current indentation level
  get(): string {
    let indent = oneIndentation;
    for (let i = 1; i < this.level; ++i) {
      indent += oneIndentation;
    }
    return indent;
  }

  // increments the indentation level
  push(): indentation {
    ++this.level;
    return this;
  }

  // decrements the indentation level
  pop(): indentation {
    --this.level;
    if (this.level < 1) {
      throw new Error('indentation stack underflow');
    }
    return this;
  }
}

// emits the derive annotation with the standard and any additional values
export function annotationDerive(...extra: Array<string>): string {
  const derive = new Array<string>('Clone', 'Debug', 'Deserialize', 'Serialize');
  // remove any empty values
  extra = extra.filter(entry => entry.trim() !== '');
  derive.push(...extra);
  derive.sort();
  return `#[derive(${derive.join(', ')})]\n`;
}

// used to sort strings in ascending order
export function sortAscending(a: string, b: string): number {
  return a < b ? -1 : a > b ? 1 : 0;
}
